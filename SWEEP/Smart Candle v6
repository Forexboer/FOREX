//+------------------------------------------------------------------+
//|                                              SmartCandleV6.mq5   |
//|                       MQL5 Expert Advisor implementing the       |
//|                       "Smart Candle V6" strategy.                |
//|                                                                  |
//|  This EA reads a decisive candle on a user‑specified timeframe   |
//|  at a specific closing time and opens a trade on the next bar    |
//|  based on the candle's direction.  Various stop‑loss and take‑   |
//|  profit methods are supported, including fixed, ATR‑based and     |
//|  swing high/low approaches.  Risk management can use a fixed     |
//|  lot size or a dynamic lot calculated from the account balance   |
//|  and distance to the stop loss.  The code uses the CTrade class  |
//|  of the standard library to send trade requests.  ATR indicator  |
//|  values are obtained via indicator handles and CopyBuffer() as    |
//|  required by MQL5【718389191056773†L83-L113】.                       |
//|                                                                  |
//|  NOTE: This EA is provided for educational purposes and should   |
//|  be tested on a demo account before live trading.                |
//+------------------------------------------------------------------+

#property strict
#property version   "2.0"
#property description "Smart Candle V2 Expert Advisor (MQL5)"

// Include trade class for order operations
#include <Trade\Trade.mqh>

//---- input parameters ---------------------------------------------------
input int              MagicNumber         = 20231117;    // Magic number for identification
input ENUM_TIMEFRAMES  DecisionTimeframe   = PERIOD_H1;    // Timeframe of the decisive candle
input string           DecisionTime        = "04:00";     // Closing time of decisive candle (HH:MM server time)

//---- day of week filter: Sunday=0 ... Saturday=6 -----------------------
input bool             AllowMonday         = true;        // Trade on Monday
input bool             AllowTuesday        = true;        // Trade on Tuesday
input bool             AllowWednesday      = true;        // Trade on Wednesday
input bool             AllowThursday       = true;        // Trade on Thursday
input bool             AllowFriday         = true;        // Trade on Friday

input bool             UseOneTradePerDay   = true;        // Enforce one trade per day
input bool             UseNewsFilter       = false;       // Placeholder for news filter (not implemented)

//---- HTF EMA trend filter (entry gate) -------------------------------
input bool             UseHTF_EMA_Filter   = false;      // Enable HTF EMA filter for entries
input ENUM_TIMEFRAMES  TrendEMA_TF         = PERIOD_H4;  // Timeframe for HTF trend EMAs
input int              TrendEMA_Fast       = 40;         // Fast EMA period
input int              TrendEMA_Slow       = 50;         // Slow EMA period

//---- stop loss options --------------------------------------------------
enum StopLossMethod
  {
   SL_Fixed        = 0,   // Fixed stop loss in pips
   SL_CandleRange  = 1,   // Use high/low of decisive candle
   SL_ATR_Old      = 2,   // ATR stop loss using same timeframe
   SL_Swing        = 3,   // Swing high/low based stop loss
   SL_ATR_Custom   = 4    // ATR stop loss using custom timeframe
  };

input StopLossMethod SL_Method       = SL_Fixed;
input double         FixedSLPips     = 50.0;       // Pips for fixed SL
input int            ATR_SL_Period   = 14;         // ATR period for old method
input double         ATR_SL_Mult     = 1.0;        // ATR multiplier for old method
input int            SwingLookback   = 5;          // Lookback bars for swing SL
input int            ATR_Custom_Per  = 14;         // ATR period for custom timeframe
input double         ATR_Custom_Mult = 1.0;        // ATR multiplier for custom timeframe
input ENUM_TIMEFRAMES ATR_Custom_TF  = PERIOD_H4;  // ATR timeframe for custom SL
input bool           UseMaxSL_Pips   = true;       // Cap SL at MaxSL_Pips
input double         MaxSL_Pips      = 200;        // Maximum SL distance in pips

//---- take profit options -------------------------------------------------
enum TakeProfitMethod
  {
   TP_Fixed   = 0,  // Fixed take profit in pips
   TP_ATR     = 1   // ATR based take profit (same timeframe)
  };

input TakeProfitMethod TP_Method      = TP_Fixed;
input double           FixedTPPips    = 100.0;      // Pips for fixed TP
input int              ATR_TP_Period  = 14;         // ATR period for TP
input double           ATR_TP_Mult    = 2.0;        // ATR multiplier for TP

//---- risk management options --------------------------------------------
enum RiskMethod
  {
   RM_FixedLot = 0,      // Always trade fixed lot size
   RM_RiskPct  = 1       // Risk a percentage of account balance
  };

input RiskMethod        RM_Method      = RM_FixedLot;
input double            FixedLotSize   = 0.10;      // Fixed lot size when RM_FixedLot
input double            RiskPercent    = 1.0;       // Percentage of balance to risk per trade (0..100)

//---- exit modules -------------------------------------------------------
input bool              UseTimeExit         = false;                 // Enable time-based exit
input int               MaxTradeMinutes     = 0;                     // Max trade duration (minutes); 0 disables
input bool              EnableExitLogging   = false;                 // Enable exit logging to CSV
input string            ExitLogFile         = "SmartCandleV2_ExitLog.csv"; // Exit log file name

//---- profit protection: lock profit ------------------------------------
input bool              UseLockProfit       = false;                 // Enable lock-profit protection
input double            LockTriggerPoints   = 200.0;                 // Trigger (points in profit) to lock
input double            LockBufferPoints    = 10.0;                  // Buffer (points) beyond break-even
input bool              UseFixedLockLevel   = false;                 // Use fixed lock level instead of break-even+buffer
input double            FixedLockPoints     = 50.0;                  // Fixed lock level (points from entry)

//---- trailing stop: profit build ---------------------------------------
input bool              UseTrailingStop     = false;                 // Enable trailing stop
input double            TrailStartPoints    = 300.0;                 // Start trailing after this profit (points)
input double            TrailDistancePoints = 150.0;                 // Trailing distance (points)
input double            TrailStepPoints     = 0.0;                   // Minimum improvement (points) to update

//---- EMA slope exit: trend exit ----------------------------------------
input bool              UseEMA_Slope_Exit   = false;                 // Enable EMA slope exit
input ENUM_TIMEFRAMES   SlopeEMA_TF         = PERIOD_H4;             // Timeframe for EMA slope
input int               SlopeEMA_Period     = 40;                    // EMA period for slope
input int               SlopeLookbackN      = 3;                     // Lookback bars for slope
input double            SlopeThreshold      = 0.0;                   // Slope threshold (price units)

//---- internal state variables ------------------------------------------
int     g_decisionMinutes     = 0;        // Minutes after midnight for decisive candle close
datetime g_lastBarTime        = 0;        // Last processed bar time on DecisionTimeframe
int     g_lastTradeDayOfYear  = -1;       // Day of year of the last trade (for one trade per day)
datetime g_lastHtfEmaLogTime  = 0;        // Last bar time for HTF EMA log gating
datetime g_lastSlopeBarTime   = 0;        // Last bar time for EMA slope exit

// ATR indicator handles (created on demand)
int atrHandleSL  = INVALID_HANDLE;        // Handle for ATR used in stop loss (old method)
int atrHandleTP  = INVALID_HANDLE;        // Handle for ATR used in take profit
int atrHandleCustomSL = INVALID_HANDLE;   // Handle for custom timeframe ATR for stop loss

// Trend EMA handles for entry filter
int trendEmaFastHandle = INVALID_HANDLE;
int trendEmaSlowHandle = INVALID_HANDLE;
int slopeEmaHandle     = INVALID_HANDLE;

// Trade object
CTrade trade;

//+------------------------------------------------------------------+
//| Parse the HH:MM decision time string to minutes after midnight   |
//+------------------------------------------------------------------+
int ParseDecisionMinutes(const string timeStr)
  {
   int colonPos = StringFind(timeStr, ":");
   if(colonPos > 0)
     {
      string hh = StringSubstr(timeStr, 0, colonPos);
      string mm = StringSubstr(timeStr, colonPos + 1);
      int hour  = (int)StringToInteger(hh);
      int minute= (int)StringToInteger(mm);
      return(hour * 60 + minute);
     }
   return(0);
  }

//+------------------------------------------------------------------+
//| Indicator value fetcher for ATR                                  |
//| Fetches the ATR value at the given shift (start_pos) from the    |
//| indicator handle using CopyBuffer()【573739094363470†L76-L120】.             |
//+------------------------------------------------------------------+
double GetATR(int handle, int shift)
  {
   if(handle == INVALID_HANDLE)
      return(0.0);
   double buffer[];
   ArraySetAsSeries(buffer, true);
   // Copy one value at the specified shift
   int copied = CopyBuffer(handle, 0, shift, 1, buffer);
   if(copied == 1)
      return(buffer[0]);
   return(0.0);
  }

//+------------------------------------------------------------------+
//| Indicator value fetcher for EMA                                  |
//+------------------------------------------------------------------+
double GetEMA(int handle, int shift)
  {
   if(handle == INVALID_HANDLE)
      return(0.0);
   double buffer[];
   ArraySetAsSeries(buffer, true);
   int copied = CopyBuffer(handle, 0, shift, 1, buffer);
   if(copied == 1)
      return(buffer[0]);
   return(0.0);
  }

//+------------------------------------------------------------------+
//| Determine if a new bar has opened for a timeframe                |
//+------------------------------------------------------------------+
bool IsNewBar(ENUM_TIMEFRAMES tf, datetime &lastBarTime)
  {
   datetime currentBarTime = iTime(_Symbol, tf, 0);
   if(currentBarTime <= 0)
      return(false);
   if(currentBarTime != lastBarTime)
     {
      lastBarTime = currentBarTime;
      return(true);
     }
   return(false);
  }

//+------------------------------------------------------------------+
//| Fetch EMA value safely using CopyBuffer                          |
//+------------------------------------------------------------------+
bool GetEMAValue(int handle, int shift, double &value)
  {
   value = 0.0;
   if(handle == INVALID_HANDLE)
      return(false);
   double buffer[];
   ArraySetAsSeries(buffer, true);
   int copied = CopyBuffer(handle, 0, shift, 1, buffer);
   if(copied != 1)
      return(false);
   value = buffer[0];
   return(true);
  }

//+------------------------------------------------------------------+
//| Check if trading is allowed on the given day of week             |
//+------------------------------------------------------------------+
bool DayAllowed(int dayOfWeek)
  {
   // dayOfWeek: 0=Sunday, 1=Monday, ..., 6=Saturday
   if(dayOfWeek == 1 && AllowMonday)        return(true);
   if(dayOfWeek == 2 && AllowTuesday)       return(true);
   if(dayOfWeek == 3 && AllowWednesday)     return(true);
   if(dayOfWeek == 4 && AllowThursday)      return(true);
   if(dayOfWeek == 5 && AllowFriday)        return(true);
   return(false); // Weekends not allowed
  }

//+------------------------------------------------------------------+
//| Placeholder for news filter. Returns false if not blocked.       |
//+------------------------------------------------------------------+
bool NewsBlocked()
  {
   if(!UseNewsFilter)
      return(false);
   // Real news filtering would require external data. Not implemented.
   return(false);
  }

//+------------------------------------------------------------------+
//| Determine HTF EMA trend permissions for entries                  |
//+------------------------------------------------------------------+
bool GetHTFDirectionAllow(bool &buyAllowed, bool &sellAllowed)
  {
   buyAllowed = true;
   sellAllowed = true;
   if(!UseHTF_EMA_Filter)
      return(true);

   if(trendEmaFastHandle == INVALID_HANDLE)
      trendEmaFastHandle = iMA(_Symbol, TrendEMA_TF, TrendEMA_Fast, 0, MODE_EMA, PRICE_CLOSE);
   if(trendEmaSlowHandle == INVALID_HANDLE)
      trendEmaSlowHandle = iMA(_Symbol, TrendEMA_TF, TrendEMA_Slow, 0, MODE_EMA, PRICE_CLOSE);

   if(trendEmaFastHandle == INVALID_HANDLE || trendEmaSlowHandle == INVALID_HANDLE)
     {
      buyAllowed = false;
      sellAllowed = false;
      if(IsNewBar(TrendEMA_TF, g_lastHtfEmaLogTime))
         Print("HTF EMA filter handles are invalid.");
      return(false);
     }

   double emaFast = 0.0;
   double emaSlow = 0.0;
   if(!GetEMAValue(trendEmaFastHandle, 1, emaFast) || !GetEMAValue(trendEmaSlowHandle, 1, emaSlow))
     {
      buyAllowed = false;
      sellAllowed = false;
      if(IsNewBar(TrendEMA_TF, g_lastHtfEmaLogTime))
         Print("HTF EMA filter data unavailable.");
      return(false);
     }

   if(emaFast > emaSlow)
     {
      buyAllowed = true;
      sellAllowed = false;
     }
   else if(emaFast < emaSlow)
     {
      buyAllowed = false;
      sellAllowed = true;
     }
   else
     {
      buyAllowed = false;
      sellAllowed = false;
     }
   return(true);
  }

//+------------------------------------------------------------------+
//| Calculate position profit in points                              |
//+------------------------------------------------------------------+
double GetPositionProfitPoints(const long positionType, const double openPrice)
  {
   if(positionType == POSITION_TYPE_BUY)
      return((SymbolInfoDouble(_Symbol, SYMBOL_BID) - openPrice) / _Point);
   return((openPrice - SymbolInfoDouble(_Symbol, SYMBOL_ASK)) / _Point);
  }

//+------------------------------------------------------------------+
//| Check if an SL modification respects broker stops/freeze         |
//+------------------------------------------------------------------+
bool CanModifyStop(const long positionType, const double desiredSl)
  {
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double currentPrice = (positionType == POSITION_TYPE_BUY ? bid : ask);
   if(positionType == POSITION_TYPE_BUY && desiredSl >= bid)
      return(false);
   if(positionType == POSITION_TYPE_SELL && desiredSl <= ask)
      return(false);

   int stopsLevel = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
   int freezeLevel = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_FREEZE_LEVEL);
   double distancePoints = MathAbs(currentPrice - desiredSl) / _Point;
   if(stopsLevel > 0 && distancePoints < stopsLevel)
      return(false);
   if(freezeLevel > 0 && distancePoints <= freezeLevel)
      return(false);
   return(true);
  }

//+------------------------------------------------------------------+
//| Apply lock profit to position                                    |
//+------------------------------------------------------------------+
bool ApplyLockProfitToPosition(ulong ticket)
  {
   if(!UseLockProfit)
      return(false);
   if(!PositionSelectByTicket(ticket))
      return(false);

   long positionType = PositionGetInteger(POSITION_TYPE);
   double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   double currentSl = PositionGetDouble(POSITION_SL);
   double tp = PositionGetDouble(POSITION_TP);

   double profitPoints = GetPositionProfitPoints(positionType, openPrice);
   if(profitPoints < LockTriggerPoints)
      return(false);

   double desiredSl;
   if(UseFixedLockLevel)
     {
      desiredSl = (positionType == POSITION_TYPE_BUY
                   ? openPrice + FixedLockPoints * _Point
                   : openPrice - FixedLockPoints * _Point);
     }
   else
     {
      desiredSl = (positionType == POSITION_TYPE_BUY
                   ? openPrice + LockBufferPoints * _Point
                   : openPrice - LockBufferPoints * _Point);
     }
   desiredSl = NormalizeDouble(desiredSl, _Digits);

   if(positionType == POSITION_TYPE_BUY)
     {
      if(currentSl != 0.0 && desiredSl <= currentSl)
         return(false);
     }
   else
     {
      if(currentSl != 0.0 && desiredSl >= currentSl)
         return(false);
     }
   if(!CanModifyStop(positionType, desiredSl))
      return(false);

   trade.SetExpertMagicNumber(MagicNumber);
   return(trade.PositionModify(_Symbol, desiredSl, tp));
  }

//+------------------------------------------------------------------+
//| Apply trailing stop to position                                  |
//+------------------------------------------------------------------+
bool ApplyTrailingStopToPosition(ulong ticket)
  {
   if(!UseTrailingStop)
      return(false);
   if(!PositionSelectByTicket(ticket))
      return(false);

   long positionType = PositionGetInteger(POSITION_TYPE);
   double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   double currentSl = PositionGetDouble(POSITION_SL);
   double tp = PositionGetDouble(POSITION_TP);
   double profitPoints = GetPositionProfitPoints(positionType, openPrice);
   if(profitPoints < TrailStartPoints)
      return(false);

   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double desiredSl = (positionType == POSITION_TYPE_BUY
                       ? bid - TrailDistancePoints * _Point
                       : ask + TrailDistancePoints * _Point);
   desiredSl = NormalizeDouble(desiredSl, _Digits);

   if(positionType == POSITION_TYPE_BUY)
     {
      if(currentSl != 0.0 && desiredSl <= currentSl)
         return(false);
      if(TrailStepPoints > 0.0 && currentSl != 0.0)
        {
         double improvement = (desiredSl - currentSl) / _Point;
         if(improvement < TrailStepPoints)
            return(false);
        }
     }
   else
     {
      if(currentSl != 0.0 && desiredSl >= currentSl)
         return(false);
      if(TrailStepPoints > 0.0 && currentSl != 0.0)
        {
         double improvement = (currentSl - desiredSl) / _Point;
         if(improvement < TrailStepPoints)
            return(false);
        }
     }
   if(!CanModifyStop(positionType, desiredSl))
      return(false);

   trade.SetExpertMagicNumber(MagicNumber);
   return(trade.PositionModify(_Symbol, desiredSl, tp));
  }

//+------------------------------------------------------------------+
//| Check EMA slope exit and close position if triggered             |
//+------------------------------------------------------------------+
bool CheckAndCloseByEMASlope(ulong ticket, const long positionType)
  {
   if(!UseEMA_Slope_Exit)
      return(false);
   if(!PositionSelectByTicket(ticket))
      return(false);

   if(slopeEmaHandle == INVALID_HANDLE)
      slopeEmaHandle = iMA(_Symbol, SlopeEMA_TF, SlopeEMA_Period, 0, MODE_EMA, PRICE_CLOSE);
   if(slopeEmaHandle == INVALID_HANDLE)
      return(false);

   double emaNow = 0.0;
   double emaPast = 0.0;
   if(!GetEMAValue(slopeEmaHandle, 1, emaNow))
      return(false);
   if(!GetEMAValue(slopeEmaHandle, 1 + SlopeLookbackN, emaPast))
      return(false);

   double slope = emaNow - emaPast;
   if(positionType == POSITION_TYPE_BUY)
     {
      if(slope <= SlopeThreshold)
         return(TryClosePosition(ticket, "EMASlopeExit", -1));
     }
   else
     {
      if(slope >= -SlopeThreshold)
         return(TryClosePosition(ticket, "EMASlopeExit", -1));
     }
   return(false);
  }

//+------------------------------------------------------------------+
//| Check time-based exit                                            |
//+------------------------------------------------------------------+
bool IsTimeExitTriggered(ulong ticket, int maxMinutes, int &durationMin)
  {
   durationMin = 0;
   if(!UseTimeExit || maxMinutes <= 0)
      return(false);
   if(!PositionSelectByTicket(ticket))
      return(false);
   datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
   int elapsed = (int)((TimeCurrent() - openTime) / 60);
   durationMin = elapsed;
   if(elapsed >= maxMinutes)
      return(true);
   return(false);
  }

//+------------------------------------------------------------------+
//| Log exit to CSV                                                  |
//+------------------------------------------------------------------+
void LogExitToCSV(const string reason,
                  const string symbol,
                  const ulong ticket,
                  const long positionType,
                  const double volume,
                  const datetime openTime,
                  const datetime closeTime,
                  const int durationMin,
                  const double openPrice,
                  const double closePrice,
                  const double profit)
  {
   if(!EnableExitLogging)
      return;
   int file = FileOpen(ExitLogFile, FILE_READ | FILE_WRITE | FILE_CSV | FILE_ANSI);
   if(file == INVALID_HANDLE)
     {
      Print("Failed to open exit log file: ", ExitLogFile, " Error=", GetLastError());
      return;
     }
   bool writeHeader = (FileSize(file) == 0);
   FileSeek(file, 0, SEEK_END);
   if(writeHeader)
     {
      FileWrite(file, "timestamp", "symbol", "ticket", "type", "lots", "openTime", "closeTime",
                "durationMin", "openPrice", "closePrice", "profit", "reason");
     }
   string typeStr = (positionType == POSITION_TYPE_BUY ? "BUY" : "SELL");
   FileWrite(file,
             TimeToString(closeTime, TIME_DATE | TIME_SECONDS),
             symbol,
             (long)ticket,
             typeStr,
             DoubleToString(volume, 2),
             TimeToString(openTime, TIME_DATE | TIME_SECONDS),
             TimeToString(closeTime, TIME_DATE | TIME_SECONDS),
             durationMin,
             DoubleToString(openPrice, _Digits),
             DoubleToString(closePrice, _Digits),
             DoubleToString(profit, 2),
             reason);
   FileClose(file);
  }

//+------------------------------------------------------------------+
//| Attempt to close a position and log exit reason                  |
//+------------------------------------------------------------------+
bool TryClosePosition(ulong ticket, const string reason, int durationMin)
  {
   if(!PositionSelectByTicket(ticket))
      return(false);

   string symbol = PositionGetString(POSITION_SYMBOL);
   long positionType = PositionGetInteger(POSITION_TYPE);
   double volume = PositionGetDouble(POSITION_VOLUME);
   datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
   double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);

   if(durationMin < 0)
      durationMin = (int)((TimeCurrent() - openTime) / 60);

   trade.SetExpertMagicNumber(MagicNumber);

   bool closed = false;
   for(int attempt = 0; attempt < 2; attempt++)
     {
      if(trade.PositionClose(ticket))
        {
         closed = (trade.ResultRetcode() == TRADE_RETCODE_DONE);
         if(closed)
            break;
        }
     }

   if(!closed)
     {
      Print("Position close failed for ticket ", ticket, ". Retcode=", trade.ResultRetcode(),
            " ", trade.ResultRetcodeDescription());
      return(false);
     }

   datetime closeTime = TimeCurrent();
   double closePrice = trade.ResultPrice();
   double profit = 0.0;
   ulong dealTicket = trade.ResultDeal();
   if(dealTicket > 0)
     {
      if(HistorySelect(openTime, closeTime))
        {
         if(HistoryDealSelect(dealTicket))
           {
            closeTime = (datetime)HistoryDealGetInteger(dealTicket, DEAL_TIME);
            closePrice = HistoryDealGetDouble(dealTicket, DEAL_PRICE);
            profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
           }
        }
     }

   LogExitToCSV(reason, symbol, ticket, positionType, volume, openTime, closeTime,
                durationMin, openPrice, closePrice, profit);
   return(true);
  }

//+------------------------------------------------------------------+
//| Central manager for open positions                               |
//+------------------------------------------------------------------+
void ManageOpenPositions()
  {
   bool slopeNewBar = false;
   if(UseEMA_Slope_Exit)
      slopeNewBar = IsNewBar(SlopeEMA_TF, g_lastSlopeBarTime);

   for(int pos = PositionsTotal() - 1; pos >= 0; pos--)
     {
      ulong ticket = PositionGetTicket(pos);
      if(!PositionSelectByTicket(ticket))
         continue;
      long magic = PositionGetInteger(POSITION_MAGIC);
      string sym = PositionGetString(POSITION_SYMBOL);
      if(magic != MagicNumber || sym != _Symbol)
         continue;

      int durationMin = 0;
      if(IsTimeExitTriggered(ticket, MaxTradeMinutes, durationMin))
        {
         if(TryClosePosition(ticket, "TimeExit", durationMin))
            continue;
        }

      if(UseLockProfit)
         ApplyLockProfitToPosition(ticket);
      if(UseTrailingStop)
         ApplyTrailingStopToPosition(ticket);
      if(slopeNewBar)
        {
         long positionType = PositionGetInteger(POSITION_TYPE);
         if(CheckAndCloseByEMASlope(ticket, positionType))
            continue;
        }
     }
  }

//+------------------------------------------------------------------+
//| Calculates dynamic lot size based on risk percentage.            |
//| Uses symbol properties for tick size, tick value and volume      |
//| limits【777576027852568†L390-L460】.                               |
//+------------------------------------------------------------------+
double CalculateLotSize(double entryPrice, double stopPrice, double riskPct)
  {
   // Return fixed lot if RM is fixed
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount     = accountBalance * riskPct / 100.0;
   double distance       = MathAbs(entryPrice - stopPrice);
   if(distance <= 0.0 || riskAmount <= 0.0)
      return(0.0);
   // Retrieve tick size and tick value for profit or loss
   double tickSize    = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue   = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE); // value per tick
   if(tickSize <= 0.0 || tickValue <= 0.0)
      return(0.0);
   // Convert price distance into ticks
   double ticks       = distance / tickSize;
   // Cost of one lot for the distance
   double costPerLot  = ticks * tickValue;
   if(costPerLot <= 0.0)
      return(0.0);
   // Calculate raw lots
   double lots        = riskAmount / costPerLot;
   return(lots);
  }

//+------------------------------------------------------------------+
//| Normalize lot size to allowed broker constraints                 |
//+------------------------------------------------------------------+
double NormalizeLotSize(double lots)
  {
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep= SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   if(lotStep <= 0.0)
      lotStep = 1.0;
   if(lots < minLot)
      lots = minLot;
   if(lots > maxLot)
      lots = maxLot;
   // Align to volume step
   lots = MathFloor(lots / lotStep) * lotStep;
   return(lots);
  }

//+------------------------------------------------------------------+
//| Apply max SL cap in pips and validate SL distance                |
//+------------------------------------------------------------------+
bool ApplyMaxSLPips(ENUM_ORDER_TYPE type, double entryPrice, double calculatedSL,
                    double &finalSL, double &slPips, bool &wasCapped)
  {
   double pipSize = (_Digits == 3 || _Digits == 5) ? (_Point * 10.0) : _Point;
   if(type == ORDER_TYPE_BUY)
      slPips = (entryPrice - calculatedSL) / pipSize;
   else
      slPips = (calculatedSL - entryPrice) / pipSize;

   PrintFormat("SL calculated: %.1f pips (price=%s)", slPips, DoubleToString(calculatedSL, _Digits));

   if(slPips <= 0.0)
     {
      PrintFormat("Invalid SL distance (<= 0 pips). Entry=%s SL=%s. Trade not opened.",
                  DoubleToString(entryPrice, _Digits), DoubleToString(calculatedSL, _Digits));
      return(false);
     }

   finalSL = calculatedSL;
   wasCapped = false;

   if(UseMaxSL_Pips && slPips > MaxSL_Pips)
     {
      if(type == ORDER_TYPE_BUY)
         finalSL = entryPrice - (MaxSL_Pips * pipSize);
      else
         finalSL = entryPrice + (MaxSL_Pips * pipSize);
      wasCapped = true;
      PrintFormat("MaxSL cap applied: %.1f pips -> %.1f pips (price=%s)",
                  slPips, MaxSL_Pips, DoubleToString(finalSL, _Digits));
     }

   finalSL = NormalizeDouble(finalSL, _Digits);
   return(true);
  }

//+------------------------------------------------------------------+
//| Opens a market position with computed parameters using CTrade.   |
//| orderType should be ORDER_TYPE_BUY or ORDER_TYPE_SELL.            |
//+------------------------------------------------------------------+
void EnterTrade(int orderType)
  {
   // Refresh the environment
   // Determine entry price from current market quotes
   double entryPrice = 0.0;
   if(orderType == ORDER_TYPE_BUY)
      entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   else
      entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   if(entryPrice <= 0.0)
      return;

   // Compute stop loss (sl) and take profit (tp)
   double sl = 0.0;
   double tp = 0.0;

   // Fixed SL
   if(SL_Method == SL_Fixed)
     {
      double slDist = FixedSLPips * _Point;
      if(orderType == ORDER_TYPE_BUY)
         sl = entryPrice - slDist;
      else
         sl = entryPrice + slDist;
     }
   else if(SL_Method == SL_CandleRange)
     {
      // Use high/low of decisive candle (index 1)
      double decLow  = iLow(_Symbol, DecisionTimeframe, 1);
      double decHigh = iHigh(_Symbol, DecisionTimeframe, 1);
      if(orderType == ORDER_TYPE_BUY)
         sl = decLow;
      else
         sl = decHigh;
     }
   else if(SL_Method == SL_ATR_Old)
     {
      double atr = GetATR(atrHandleSL, 1);
      double dist = atr * ATR_SL_Mult;
      if(orderType == ORDER_TYPE_BUY)
         sl = entryPrice - dist;
      else
         sl = entryPrice + dist;
     }
   else if(SL_Method == SL_Swing)
     {
      // Swing high/low based on last SwingLookback bars ending at index 1
      if(orderType == ORDER_TYPE_BUY)
        {
         int lowShift = iLowest(_Symbol, DecisionTimeframe, MODE_LOW, SwingLookback, 1);
         sl = iLow(_Symbol, DecisionTimeframe, lowShift);
        }
      else
        {
         int highShift = iHighest(_Symbol, DecisionTimeframe, MODE_HIGH, SwingLookback, 1);
         sl = iHigh(_Symbol, DecisionTimeframe, highShift);
        }
     }
   else if(SL_Method == SL_ATR_Custom)
     {
      double atr = GetATR(atrHandleCustomSL, 1);
      double dist = atr * ATR_Custom_Mult;
      if(orderType == ORDER_TYPE_BUY)
         sl = entryPrice - dist;
      else
         sl = entryPrice + dist;
     }

   double finalSL = sl;
   double slPips = 0.0;
   bool wasCapped = false;
   if(!ApplyMaxSLPips((ENUM_ORDER_TYPE)orderType, entryPrice, sl, finalSL, slPips, wasCapped))
      return;
   sl = finalSL;

   // Take profit
   if(TP_Method == TP_Fixed)
     {
      double tpDist = FixedTPPips * _Point;
      if(orderType == ORDER_TYPE_BUY)
         tp = entryPrice + tpDist;
      else
         tp = entryPrice - tpDist;
     }
   else if(TP_Method == TP_ATR)
     {
      double atr = GetATR(atrHandleTP, 1);
      double dist = atr * ATR_TP_Mult;
      if(orderType == ORDER_TYPE_BUY)
         tp = entryPrice + dist;
      else
         tp = entryPrice - dist;
     }

   // Determine lot size
   double lots;
   if(RM_Method == RM_FixedLot)
     {
      lots = FixedLotSize;
     }
   else
     {
      lots = CalculateLotSize(entryPrice, sl, RiskPercent);
     }
   lots = NormalizeLotSize(lots);
   if(lots <= 0.0)
     {
      Print("Lot size calculated as zero. Trade not opened.");
      return;
     }

   // Set slippage/deviation in points (optional). Here 10 points.
   trade.SetDeviationInPoints(10);
   // Set the Magic number for this expert
   trade.SetExpertMagicNumber(MagicNumber);

   bool result;
   if(orderType == ORDER_TYPE_BUY)
     {
      result = trade.Buy(lots, _Symbol, entryPrice, sl, tp, "Smart Candle V2");
     }
   else
     {
      result = trade.Sell(lots, _Symbol, entryPrice, sl, tp, "Smart Candle V2");
     }
   if(!result)
     {
      // Failed to send trade request
      Print("OrderSend failed: ", trade.ResultRetcode(), " ", trade.ResultRetcodeDescription());
      return;
     }
   // If trade request accepted, update last trade day for one trade per day
   if(trade.ResultRetcode() == TRADE_RETCODE_DONE)
     {
      /*
         In MQL5 there is no TimeDayOfYear() function (it exists in MQL4 only).
         To obtain the day-of-year value, convert the current server time to an
         MqlDateTime structure using TimeToStruct().  The structure field
         day_of_year contains the day number starting from 0 for January 1st.
      */
      MqlDateTime nowStruct;
      datetime nowTime = TimeCurrent();
      TimeToStruct(nowTime, nowStruct);
      g_lastTradeDayOfYear = nowStruct.day_of_year;
      Print("Trade opened: Ticket=", trade.ResultOrder(), " Type=", orderType,
            " Lots=", lots, " SL=", sl, " TP=", tp);
     }
  }

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   // Parse decision time once
   g_decisionMinutes = ParseDecisionMinutes(DecisionTime);

   // Create ATR handles as needed
   // ATR for stop loss (old method) or TP if same period
   if(SL_Method == SL_ATR_Old || TP_Method == TP_ATR)
     {
      // For old SL we use ATR_SL_Period; for TP we may use ATR_TP_Period
      atrHandleSL = iATR(_Symbol, DecisionTimeframe, ATR_SL_Period);
      if(TP_Method == TP_ATR)
        {
         // If TP uses a different period, create separate handle
         if(ATR_TP_Period != ATR_SL_Period)
            atrHandleTP = iATR(_Symbol, DecisionTimeframe, ATR_TP_Period);
         else
            atrHandleTP = atrHandleSL;
        }
     }
   if(SL_Method == SL_ATR_Custom)
     {
      atrHandleCustomSL = iATR(_Symbol, ATR_Custom_TF, ATR_Custom_Per);
     }
   if(UseHTF_EMA_Filter)
     {
      trendEmaFastHandle = iMA(_Symbol, TrendEMA_TF, TrendEMA_Fast, 0, MODE_EMA, PRICE_CLOSE);
      trendEmaSlowHandle = iMA(_Symbol, TrendEMA_TF, TrendEMA_Slow, 0, MODE_EMA, PRICE_CLOSE);
     }
   if(UseEMA_Slope_Exit)
     {
      slopeEmaHandle = iMA(_Symbol, SlopeEMA_TF, SlopeEMA_Period, 0, MODE_EMA, PRICE_CLOSE);
     }
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   // Release indicator handles
   if(atrHandleSL != INVALID_HANDLE)
      IndicatorRelease(atrHandleSL);
   if(atrHandleTP != INVALID_HANDLE && atrHandleTP != atrHandleSL)
      IndicatorRelease(atrHandleTP);
   if(atrHandleCustomSL != INVALID_HANDLE)
      IndicatorRelease(atrHandleCustomSL);
   if(trendEmaFastHandle != INVALID_HANDLE)
      IndicatorRelease(trendEmaFastHandle);
   if(trendEmaSlowHandle != INVALID_HANDLE)
      IndicatorRelease(trendEmaSlowHandle);
   if(slopeEmaHandle != INVALID_HANDLE)
      IndicatorRelease(slopeEmaHandle);
  }

//+------------------------------------------------------------------+
//| Main event handler called on every tick                          |
//+------------------------------------------------------------------+
void OnTick()
  {
   ManageOpenPositions();

   // Check for a new bar on the decision timeframe
   datetime currentBarTime = iTime(_Symbol, DecisionTimeframe, 0);
   if(currentBarTime == g_lastBarTime)
      return;
   g_lastBarTime = currentBarTime;

   // Decisive candle is the previous bar (shift 1)
   datetime decTime = iTime(_Symbol, DecisionTimeframe, 1);
   if(decTime <= 0)
      return;
   // Break down the decisive candle time into its components using TimeToStruct().
   // MqlDateTime contains fields such as hour, min, day_of_week and day_of_year.
   MqlDateTime decStruct;
   TimeToStruct(decTime, decStruct);
   // Combine hour and minute into total minutes after midnight
   int decMinutes = decStruct.hour * 60 + decStruct.min;
   // Ensure the decisive candle closed exactly at the configured time
   if(decMinutes != g_decisionMinutes)
      return;
   // Check day-of-week filter. day_of_week: 0=Sunday, 1=Monday, ..., 6=Saturday
   int dow = decStruct.day_of_week;
   if(!DayAllowed(dow))
      return;
   // Check one trade per day restriction
   if(UseOneTradePerDay)
     {
      int today = decStruct.day_of_year;
      if(today == g_lastTradeDayOfYear)
         return;
      // Also ensure there is no open position on this symbol and magic number
      for(int pos=PositionsTotal()-1; pos>=0; pos--)
        {
         ulong ticket = PositionGetTicket(pos);
         if(PositionSelectByTicket(ticket))
           {
            long magic = PositionGetInteger(POSITION_MAGIC);
            string sym = PositionGetString(POSITION_SYMBOL);
            if(magic == MagicNumber && sym == _Symbol)
               return; // already an open position
           }
        }
     }
   // Check news filter
   if(NewsBlocked())
      return;
   // Determine direction of decisive candle
   double decOpen  = iOpen(_Symbol, DecisionTimeframe, 1);
   double decClose = iClose(_Symbol, DecisionTimeframe, 1);
   bool buyAllowed = true;
   bool sellAllowed = true;
   if(!GetHTFDirectionAllow(buyAllowed, sellAllowed))
      return;
   if(decClose > decOpen)
     {
      if(buyAllowed)
         EnterTrade(ORDER_TYPE_BUY);
      else
         Print("HTF EMA filter blocked BUY entry.");
     }
   else if(decClose < decOpen)
     {
      if(sellAllowed)
         EnterTrade(ORDER_TYPE_SELL);
      else
         Print("HTF EMA filter blocked SELL entry.");
     }
   else
     {
      Print("Decisive candle is doji. No trade opened.");
     }
  }
