#property strict
#include <Trade/Trade.mqh>

//+------------------------------------------------------------------+
//| Expert Advisor: BoxRangeBreakoutEA                               |
//| Generated by ChatGPT                                             |
//| Description: Box range breakout strategy with multi-session,     |
//| multiple entry methods, modular risk management and visuals.     |
//+------------------------------------------------------------------+

//--- utility helpers
double PIP()
  {
   return SymbolInfoDouble(_Symbol, SYMBOL_POINT) * ((_Digits==3 || _Digits==5)?10:1);
  }

//--- enums
enum ENUM_SL_METHOD
  {
   SL_OppositeBoxSide=0,
   SL_FixedPips,
   SL_ATR,
   SL_BoxPercent,
   SL_BoxMidpoint
  };

enum ENUM_TP_MODE
  {
   TP_ModePips=0,
   TP_ModeRMultiple
  };

//--- input groups
input group       "General"
input ulong       InpMagicNumber       =123456;    // Magic number
input double      InpLots              =0.10;      // Lots
input double      RiskPercent          =1.0;       // Risk per trade in percent
input bool        InpFridayClose       =true;      // Friday close enable
input string      InpFridayCloseTime   ="21:30";  // Friday close time

input group       "Day Filter"
input bool        TradeMonday          =true;
input bool        TradeTuesday         =true;
input bool        TradeWednesday       =true;
input bool        TradeThursday        =true;
input bool        TradeFriday          =true;
input bool        TradeSaturday        =false;
input bool        TradeSunday          =false;

input group       "Sessions"
input bool        Session1_On          =true;
input string      Session1_Start       ="00:00";
input string      Session1_End         ="03:00";
input bool        Session2_On          =false;
input string      Session2_Start       ="07:00";
input string      Session2_End         ="10:00";
input bool        Session3_On          =false;
input string      Session3_Start       ="13:00";
input string      Session3_End         ="16:00";
input bool        LimitBoxRange       =false;     // Enable/disable maximum box size limit
input double      MaxBoxPips          =90.0;      // Maximum allowed box size in pips

input group       "Entry Methods"
input bool        UseDirectBreakout    =true;
input bool        UseCandleClose       =true;
input ENUM_TIMEFRAMES ConfirmTF        =PERIOD_M5;
input int         ConfirmCloses        =2;
input string      DirectStartTime      ="00:00";   // Direct method allowed start
input string      DirectEndTime        ="23:59";   // Direct method allowed end
input string      CandleStartTime      ="00:00";   // Candle-close method allowed start
input string      CandleEndTime        ="23:59";   // Candle-close method allowed end

input group       "HTF EMA Filter"
input bool        UseHTF_EMA_Filter    =true;
input ENUM_TIMEFRAMES HTF_TF           =PERIOD_H4; // example H1/H4/D1
input int         EMA_Fast_Period      =40;
input int         EMA_Slow_Period      =50;
input int         HTF_Shift            =1;         // last CLOSED HTF candle

input group       "EMA Slope TP Filter"
input bool        UseEMA_Slope_TP_Filter =true;
input int         Slope_Lookback_Bars  =5;        // N, e.g. 3/5/10
input double      Slope_Threshold      =0.0;      // optional noise filter (in raw EMA units)

input group       "Stop Loss"
input ENUM_SL_METHOD StopLossMethod    =SL_OppositeBoxSide;
input double      SL_FixedPipsValue    =50;
input double      SL_BoxPercentValue   =50.0;
input int         SL_ATR_Period        =14;
input ENUM_TIMEFRAMES SL_ATR_TF        =PERIOD_H1;
input double      SL_ATR_Mult          =1.5;
input bool        ApplySLOnlyToCandle  =true;

input group       "Take Profit"
input bool        TP1_Enable           =true;
input ENUM_TP_MODE TP1_Mode            =TP_ModeRMultiple;
input double      TP1_Value            =1.0;   // pips or R
input double      TP1_ClosePercent     =50.0;
input bool        TP2_Enable           =true;
input ENUM_TP_MODE TP2_Mode            =TP_ModeRMultiple;
input double      TP2_Value            =2.0;
input double      TP2_ClosePercent     =30.0;
input bool        TP3_Enable           =true;
input ENUM_TP_MODE TP3_Mode            =TP_ModeRMultiple;
input double      TP3_Value            =3.0;
input double      TP3_ClosePercent     =20.0;

input group       "Breakeven"
input bool        BE_ByPips            =true;
input double      BE_TriggerPips       =30;
input bool        BE_ByR               =false;
input double      BE_TriggerR          =1.0;
input bool        BE_OnTP1             =true;
input bool        BE_OnTP2             =false;
input double      BE_BufferPips        =2;

input group       "Trailing"
input bool        UseTrailing          =true;
input double      Trail_StartPips      =30;
input bool        Trail_StartTP1       =false;
input double      Trail_DistancePips   =20;

input group       "Time based exit"
input bool        UseTimeExit          =false;
input int         ExitAfterMinutes     =120;

input group       "Daily Close"
input bool        DailyCloseMon        =false;
input string      DailyCloseMonTime    ="23:00";
input bool        DailyCloseTue        =false;
input string      DailyCloseTueTime    ="23:00";
input bool        DailyCloseWed        =false;
input string      DailyCloseWedTime    ="23:00";
input bool        DailyCloseThu        =false;
input string      DailyCloseThuTime    ="23:00";
input bool        DailyCloseFri        =false;
input string      DailyCloseFriTime    ="23:00";

input group       "ATR based"
input bool        UseATRforSL          =false;
input double      SL_ATR_GlobalMult    =1.5;
input bool        UseATRforTP1         =false;
input double      TP1_ATR_Mult         =2.0;
input bool        UseATRforTP2         =false;
input double      TP2_ATR_Mult         =3.0;
input bool        UseATRforTP3         =false;
input double      TP3_ATR_Mult         =4.0;

input group       "Rounding"
input bool        RoundSL              =false;
input double      RoundSLToPips        =10;
input bool        RoundTP              =false;
input double      RoundTPToPips        =10;

//--- structures
struct Session
  {
   bool      enabled;
   long      start_hour;
   long      start_min;
   long      end_hour;
   long      end_min;
   double    high;
   double    low;
   bool      box_ready;
   bool      buy_done;
   bool      sell_done;
   datetime  start_time;
   datetime  end_time;
   string    obj_name;
  };

//--- global variables
CTrade       trade;
Session      sessions[3];
bool         isNewBar=true;
datetime     lastBarTime=0;
int          g_last_day=-1;
int          g_htf_ema_fast_handle=INVALID_HANDLE;
int          g_htf_ema_slow_handle=INVALID_HANDLE;
datetime     g_last_htf_candle_time=0;

//--- function prototypes
void   InitSessions();
void   UpdateSessions();
bool   IsTradingDay();
bool   TimeFilter(string start, string end);
void   CheckBreakouts();
void   PlaceOrder(bool isBuy,double sl,double tp1,double tp2,double tp3);
void   ManagePositions();
void   DrawSessionBox(int idx);
void   ResetSessionBox(int idx);
void   ResetDay();
double GetATR(int period,ENUM_TIMEFRAMES tf);
double CalcStopLoss(bool isBuy,double boxHigh,double boxLow,double entry,int sl_method,double sl_distance);
double RoundLevel(double price,double step,bool up);
void   ApplyBreakeven();
void   ApplyTrailing();
void   TimeExits();
void   DailyClosures();
bool   InitializeHTFEMAHandles();
void   ReleaseHTFEMAHandles();
bool   GetHTFTrendPermissions(bool &buyAllowed,bool &sellAllowed);
bool   IsNewHTFCandle();
bool   CheckSlopeExitSignalForPosition(ulong positionTicket,bool &shouldExit);
void   ExecuteSlopeExitForPosition(ulong positionTicket);
void   ProcessSlopeExitOnNewHTFCandle();

//+------------------------------------------------------------------+
//| Expert initialization                                           |
//+------------------------------------------------------------------+
int OnInit()
  {
   trade.SetExpertMagicNumber(InpMagicNumber);
   InitSessions();
   lastBarTime=0;
   if(!InitializeHTFEMAHandles())
      return(INIT_FAILED);
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   ReleaseHTFEMAHandles();
   // delete objects
   for(int i=0;i<3;i++)
     {
      if(ObjectFind(0,sessions[i].obj_name)>=0) ObjectDelete(0,sessions[i].obj_name);
     }
  }

//+------------------------------------------------------------------+
void OnTick()
  {
   MqlDateTime dt; TimeToStruct(TimeCurrent(),dt);
   if(dt.day!=g_last_day)
     {
      g_last_day=dt.day;
      ResetDay();
     }
   if(!IsTradingDay()) return;

   UpdateSessions();
   CheckBreakouts();
   ProcessSlopeExitOnNewHTFCandle();
   ManagePositions();
   ApplyBreakeven();
   ApplyTrailing();
   TimeExits();
   DailyClosures();

   if(InpFridayClose)
     {
      MqlDateTime tm; TimeToStruct(TimeCurrent(),tm);
      if(tm.day_of_week==5)
        {
         long hour=StringToInteger(StringSubstr(InpFridayCloseTime,0,2));
         long min=StringToInteger(StringSubstr(InpFridayCloseTime,3,2));
         datetime close_time=StructToTime(tm); close_time=close_time - tm.hour*3600 - tm.min*60 + hour*3600 + min*60;
         if(TimeCurrent()>=close_time)
           {
            // close all positions
            for(int i=PositionsTotal()-1;i>=0;i--)
              {
               ulong ticket=PositionGetTicket(i);
               if(PositionGetInteger(POSITION_MAGIC)==InpMagicNumber)
                  trade.PositionClose(ticket);
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
void InitSessions()
  {
   string starts[3]={Session1_Start,Session2_Start,Session3_Start};
   string ends[3]={Session1_End,Session2_End,Session3_End};
   bool   enableds[3]={Session1_On,Session2_On,Session3_On};

   for(int i=0;i<3;i++)
     {
      sessions[i].enabled=enableds[i];
      sessions[i].high=0; sessions[i].low=0; sessions[i].box_ready=false;
      sessions[i].buy_done=false; sessions[i].sell_done=false;
      sessions[i].obj_name=StringFormat("SessionBox_%d",i);
      if(enableds[i])
        {
         sessions[i].start_hour=StringToInteger(StringSubstr(starts[i],0,2));
         sessions[i].start_min=StringToInteger(StringSubstr(starts[i],3,2));
         sessions[i].end_hour=StringToInteger(StringSubstr(ends[i],0,2));
         sessions[i].end_min=StringToInteger(StringSubstr(ends[i],3,2));
        }
     }
  }

//+------------------------------------------------------------------+
void ResetSessionBox(int i)
  {
   sessions[i].high=0;
   sessions[i].low=0;
   sessions[i].box_ready=false;
   sessions[i].buy_done=false;
   sessions[i].sell_done=false;
   if(ObjectFind(0,sessions[i].obj_name)>=0) ObjectDelete(0,sessions[i].obj_name);
  }

void ResetDay()
  {
   for(int i=0;i<3;i++)
      ResetSessionBox(i);
  }

//+------------------------------------------------------------------+
void UpdateSessions()
  {
   MqlDateTime tm; TimeToStruct(TimeCurrent(),tm);
   for(int i=0;i<3;i++)
     {
      if(!sessions[i].enabled) continue;
      datetime st=StructToTime(tm) - tm.hour*3600 - tm.min*60 - tm.sec + sessions[i].start_hour*3600 + sessions[i].start_min*60;
      datetime en=StructToTime(tm) - tm.hour*3600 - tm.min*60 - tm.sec + sessions[i].end_hour*3600 + sessions[i].end_min*60;
      if(TimeCurrent()<st) { ResetSessionBox(i); continue; }
      if(TimeCurrent()>=st && TimeCurrent()<=en)
        {
         if(!sessions[i].box_ready)
           {
            double barHigh=iHigh(_Symbol,PERIOD_CURRENT,0);
            double barLow=iLow(_Symbol,PERIOD_CURRENT,0);
            if(sessions[i].high==0 || barHigh>sessions[i].high) sessions[i].high=barHigh;
            if(sessions[i].low==0 || barLow<sessions[i].low) sessions[i].low=barLow;
            sessions[i].start_time=st;
            sessions[i].end_time=en;
            DrawSessionBox(i);
           }
        }
      if(TimeCurrent()>en && !sessions[i].box_ready)
        {
         sessions[i].box_ready=true;
         DrawSessionBox(i);
        }
     }
  }

//+------------------------------------------------------------------+
bool IsTradingDay()
  {
   MqlDateTime tm; TimeToStruct(TimeCurrent(),tm);
   bool days[7]={TradeSunday,TradeMonday,TradeTuesday,TradeWednesday,TradeThursday,TradeFriday,TradeSaturday};
   if(!days[tm.day_of_week]) return false;
   return true;
  }

//+------------------------------------------------------------------+
bool TimeFilter(string start,string end)
  {
   long sh=StringToInteger(StringSubstr(start,0,2));
   long sm=StringToInteger(StringSubstr(start,3,2));
   long eh=StringToInteger(StringSubstr(end,0,2));
   long em=StringToInteger(StringSubstr(end,3,2));
   MqlDateTime tm; TimeToStruct(TimeCurrent(),tm);
   datetime st=StructToTime(tm) - tm.hour*3600 - tm.min*60 - tm.sec + sh*3600 + sm*60;
   datetime en=StructToTime(tm) - tm.hour*3600 - tm.min*60 - tm.sec + eh*3600 + em*60;
   if(TimeCurrent()>=st && TimeCurrent()<=en) return true;
   return false;
  }

//+------------------------------------------------------------------+
bool InitializeHTFEMAHandles()
  {
   if(!UseHTF_EMA_Filter && !UseEMA_Slope_TP_Filter)
      return true;
   g_htf_ema_fast_handle=iMA(_Symbol,HTF_TF,EMA_Fast_Period,0,MODE_EMA,PRICE_CLOSE);
   if(g_htf_ema_fast_handle==INVALID_HANDLE)
     {
      Print("Failed to create HTF fast EMA handle");
      return false;
     }
   g_htf_ema_slow_handle=iMA(_Symbol,HTF_TF,EMA_Slow_Period,0,MODE_EMA,PRICE_CLOSE);
   if(g_htf_ema_slow_handle==INVALID_HANDLE)
     {
      Print("Failed to create HTF slow EMA handle");
      return false;
     }
   return true;
  }

//+------------------------------------------------------------------+
void ReleaseHTFEMAHandles()
  {
   if(g_htf_ema_fast_handle!=INVALID_HANDLE)
     {
      IndicatorRelease(g_htf_ema_fast_handle);
      g_htf_ema_fast_handle=INVALID_HANDLE;
     }
   if(g_htf_ema_slow_handle!=INVALID_HANDLE)
     {
      IndicatorRelease(g_htf_ema_slow_handle);
      g_htf_ema_slow_handle=INVALID_HANDLE;
     }
  }

//+------------------------------------------------------------------+
bool GetHTFTrendPermissions(bool &buyAllowed,bool &sellAllowed)
  {
   buyAllowed=true;
   sellAllowed=true;
   if(!UseHTF_EMA_Filter)
      return true;
   if(g_htf_ema_fast_handle==INVALID_HANDLE || g_htf_ema_slow_handle==INVALID_HANDLE)
      return false;
   double emaFast[];
   double emaSlow[];
   ArraySetAsSeries(emaFast,true);
   ArraySetAsSeries(emaSlow,true);
   if(CopyBuffer(g_htf_ema_fast_handle,0,HTF_Shift,1,emaFast)<1)
      return false;
   if(CopyBuffer(g_htf_ema_slow_handle,0,HTF_Shift,1,emaSlow)<1)
      return false;
   if(emaFast[0]>emaSlow[0])
     {
      buyAllowed=true;
      sellAllowed=false;
     }
   else if(emaFast[0]<emaSlow[0])
     {
      buyAllowed=false;
      sellAllowed=true;
     }
   else
     {
      buyAllowed=false;
      sellAllowed=false;
     }
   return true;
  }

//+------------------------------------------------------------------+
bool IsNewHTFCandle()
  {
   datetime htf_time=iTime(_Symbol,HTF_TF,0);
   if(htf_time==0)
      return false;
   if(g_last_htf_candle_time!=htf_time)
     {
      g_last_htf_candle_time=htf_time;
      return true;
     }
   return false;
  }

//+------------------------------------------------------------------+
bool CheckSlopeExitSignalForPosition(ulong positionTicket,bool &shouldExit)
  {
   shouldExit=false;
   if(!UseEMA_Slope_TP_Filter)
      return true;
   if(g_htf_ema_fast_handle==INVALID_HANDLE || g_htf_ema_slow_handle==INVALID_HANDLE)
      return false;
   if(!PositionSelectByTicket(positionTicket))
      return false;
   ENUM_POSITION_TYPE position_type=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   bool isBuy=position_type==POSITION_TYPE_BUY;
   int lookback=Slope_Lookback_Bars;
   if(lookback<1)
      lookback=1;
   double emaFast[];
   double emaSlow[];
   ArraySetAsSeries(emaFast,true);
   ArraySetAsSeries(emaSlow,true);
   int needed=lookback+1;
   ArrayResize(emaFast,needed);
   ArrayResize(emaSlow,needed);
   if(CopyBuffer(g_htf_ema_fast_handle,0,1,needed,emaFast)<needed)
      return false;
   if(CopyBuffer(g_htf_ema_slow_handle,0,1,needed,emaSlow)<needed)
      return false;
   double emaFastNow=emaFast[0];
   double emaFastPrev=emaFast[lookback];
   double emaSlowNow=emaSlow[0];
   double emaSlowPrev=emaSlow[lookback];
   double slopeFast=emaFastNow-emaFastPrev;
   double slopeSlow=emaSlowNow-emaSlowPrev;
   if(isBuy)
     {
      if(slopeFast<=Slope_Threshold || slopeSlow<=Slope_Threshold)
         shouldExit=true;
      if(emaFastNow<emaSlowNow)
         shouldExit=true;
     }
   else
     {
      if(slopeFast>=-Slope_Threshold || slopeSlow>=-Slope_Threshold)
         shouldExit=true;
      if(emaFastNow>emaSlowNow)
         shouldExit=true;
     }
   return true;
  }

//+------------------------------------------------------------------+
void ExecuteSlopeExitForPosition(ulong positionTicket)
  {
   if(!PositionSelectByTicket(positionTicket))
      return;
   if(PositionGetInteger(POSITION_MAGIC)!=InpMagicNumber)
      return;
   double volume=PositionGetDouble(POSITION_VOLUME);
   bool tpen[3]={TP1_Enable,TP2_Enable,TP3_Enable};
   int enabled_count=0;
   for(int i=0;i<3;i++)
      if(tpen[i]) enabled_count++;
   double close_percent=0.0;
   if(tpen[0])
     {
      close_percent=TP1_ClosePercent;
      if(enabled_count==1)
         close_percent=100.0;
     }
   if(close_percent<=0.0 || close_percent>=100.0)
     {
      trade.PositionClose(positionTicket);
      return;
     }
   double close_vol=volume*(close_percent/100.0);
   if(close_vol>volume)
      close_vol=volume;
   if(!trade.PositionClosePartial(positionTicket,close_vol))
      trade.PositionClose(positionTicket);
  }

//+------------------------------------------------------------------+
void ProcessSlopeExitOnNewHTFCandle()
  {
   if(!UseEMA_Slope_TP_Filter)
      return;
   if(!IsNewHTFCandle())
      return;
   for(int i=PositionsTotal()-1;i>=0;i--)
     {
      ulong ticket=PositionGetTicket(i);
      if(ticket==0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC)!=InpMagicNumber) continue;
      bool shouldExit=false;
      if(!CheckSlopeExitSignalForPosition(ticket,shouldExit))
         continue;
      if(shouldExit)
         ExecuteSlopeExitForPosition(ticket);
     }
  }

//+------------------------------------------------------------------+
void CheckBreakouts()
  {
   bool permissionsChecked=false;
   bool buyAllowed=true;
   bool sellAllowed=true;
   for(int i=0;i<3;i++)
     {
      if(!sessions[i].enabled || !sessions[i].box_ready) continue;
      double high=sessions[i].high; double low=sessions[i].low;
      if(LimitBoxRange && (high-low)/PIP()>MaxBoxPips) continue; // skip large boxes
      double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);

      // direct breakout
      if(UseDirectBreakout && TimeFilter(DirectStartTime,DirectEndTime))
        {
         if(!sessions[i].buy_done && ask>high)
           {
            if(!permissionsChecked)
              {
               if(!GetHTFTrendPermissions(buyAllowed,sellAllowed))
                  return;
               permissionsChecked=true;
              }
            if(!buyAllowed)
               continue;
            double sl=CalcStopLoss(true,high,low,ask,StopLossMethod,SL_FixedPipsValue);
            double tp1=0,tp2=0,tp3=0;
            PlaceOrder(true,sl,tp1,tp2,tp3);
            sessions[i].buy_done=true;
           }
         if(!sessions[i].sell_done && bid<low)
           {
            if(!permissionsChecked)
              {
               if(!GetHTFTrendPermissions(buyAllowed,sellAllowed))
                  return;
               permissionsChecked=true;
              }
            if(!sellAllowed)
               continue;
            double sl=CalcStopLoss(false,high,low,bid,StopLossMethod,SL_FixedPipsValue);
            double tp1=0,tp2=0,tp3=0;
            PlaceOrder(false,sl,tp1,tp2,tp3);
            sessions[i].sell_done=true;
           }
        }

      // candle close breakout
      if(UseCandleClose && TimeFilter(CandleStartTime,CandleEndTime))
        {
         // check closes
         bool buy_break=true;
         bool sell_break=true;
         for(int c=1;c<=ConfirmCloses;c++)
           {
            double close=iClose(_Symbol,ConfirmTF,c); // use only closed candles
            if(close<=high) buy_break=false;
            if(close>=low) sell_break=false;
           }
         if(buy_break && !sessions[i].buy_done)
           {
            if(!permissionsChecked)
              {
               if(!GetHTFTrendPermissions(buyAllowed,sellAllowed))
                  return;
               permissionsChecked=true;
              }
            if(!buyAllowed)
               continue;
            double sl=CalcStopLoss(true,high,low,ask,StopLossMethod,SL_FixedPipsValue);
            PlaceOrder(true,sl,0,0,0);
            sessions[i].buy_done=true;
           }
         if(sell_break && !sessions[i].sell_done)
           {
            if(!permissionsChecked)
              {
               if(!GetHTFTrendPermissions(buyAllowed,sellAllowed))
                  return;
               permissionsChecked=true;
              }
            if(!sellAllowed)
               continue;
            double sl=CalcStopLoss(false,high,low,bid,StopLossMethod,SL_FixedPipsValue);
            PlaceOrder(false,sl,0,0,0);
            sessions[i].sell_done=true;
           }
        }
     }
  }

//+------------------------------------------------------------------+
double CalcStopLoss(bool isBuy,double boxHigh,double boxLow,double entry,int sl_method,double sl_distance)
  {
   double sl=0;
   double pip=PIP();
   double atr=0;
   double boxsize=boxHigh-boxLow;
   switch(sl_method)
     {
      case SL_OppositeBoxSide:
         sl = isBuy? boxLow : boxHigh; break;
      case SL_FixedPips:
         sl = isBuy? entry - sl_distance*pip : entry + sl_distance*pip; break;
      case SL_ATR:
         atr = GetATR(SL_ATR_Period,SL_ATR_TF);
         sl = isBuy? entry - atr*SL_ATR_Mult : entry + atr*SL_ATR_Mult; break;
      case SL_BoxPercent:
         if(!UseCandleClose && ApplySLOnlyToCandle) sl = isBuy? boxLow : boxHigh;
         else
           {
            double dist=boxsize*(SL_BoxPercentValue/100.0);
            sl=isBuy? entry - dist : entry + dist;
           }
         break;
      case SL_BoxMidpoint:
         if(!UseCandleClose && ApplySLOnlyToCandle) sl = isBuy? boxLow : boxHigh;
         else
           {
            double mid=(boxHigh+boxLow)/2.0;
            sl=mid;
           }
         break;
     }

   if(UseATRforSL)
     {
      double atrv=GetATR(SL_ATR_Period,SL_ATR_TF);
      sl=isBuy? entry - atrv*SL_ATR_GlobalMult : entry + atrv*SL_ATR_GlobalMult;
     }

   if(RoundSL)
     {
      double step=RoundSLToPips*pip;
      sl=RoundLevel(sl,step,!isBuy);
     }
   return sl;
  }

//+------------------------------------------------------------------+
void PlaceOrder(bool isBuy,double sl,double tp1,double tp2,double tp3)
  {
   double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double price=isBuy? ask:bid;
   double pip=PIP();
   double risk=MathAbs(price-sl);

   double lot=InpLots;
   if(RiskPercent>0.0 && risk>0.0)
     {
      double balance=AccountInfoDouble(ACCOUNT_BALANCE);
      double money_risk=balance*(RiskPercent/100.0);
      double tick_val=SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      double tick_size=SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
      double pip_value=tick_val/tick_size*pip;
      double stop_pips=risk/pip;
      if(stop_pips>0.0 && pip_value>0.0)
        {
         lot=money_risk/(stop_pips*pip_value);
         double step=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);
         double minLot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
         double maxLot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
         lot=MathFloor(lot/step)*step;
         if(lot<minLot) lot=minLot;
         if(lot>maxLot) lot=maxLot;
        }
     }

   // compute TPs
   double tpvals[3]={0,0,0};
   bool   tpen[3]={TP1_Enable,TP2_Enable,TP3_Enable};
   ENUM_TP_MODE tpmodes[3]={TP1_Mode,TP2_Mode,TP3_Mode};
   double tpinputs[3]={TP1_Value,TP2_Value,TP3_Value};
   double perc[3]={TP1_ClosePercent,TP2_ClosePercent,TP3_ClosePercent};

   double sl_dist=risk/pip;
   for(int i=0;i<3;i++)
     {
      if(!tpen[i]) continue;
      double dist=0;
      if(UseATRforTP1 && i==0) dist=GetATR(SL_ATR_Period,SL_ATR_TF)*TP1_ATR_Mult;
      else if(UseATRforTP2 && i==1) dist=GetATR(SL_ATR_Period,SL_ATR_TF)*TP2_ATR_Mult;
      else if(UseATRforTP3 && i==2) dist=GetATR(SL_ATR_Period,SL_ATR_TF)*TP3_ATR_Mult;
      else
        {
         if(tpmodes[i]==TP_ModePips) dist=tpinputs[i]*pip;
         else dist=sl_dist*tpinputs[i]*pip;
        }
      tpvals[i]= isBuy? price+dist : price-dist;
      if(RoundTP) tpvals[i]=RoundLevel(tpvals[i],RoundTPToPips*pip,isBuy);
     }

   // if only TP1 enabled, set percent to 100
   int enabled_count=0; for(int i=0;i<3;i++) if(tpen[i]) enabled_count++;
   if(enabled_count==1) perc[0]=100.0;

   trade.SetExpertMagicNumber(InpMagicNumber);
   trade.SetDeviationInPoints(10);
   double tp_final = tpen[0]?tpvals[0]:0;
   if(!trade.PositionOpen(_Symbol, isBuy?ORDER_TYPE_BUY:ORDER_TYPE_SELL, lot, price, sl, tp_final))
     {
      Print("OrderSend failed: ",trade.ResultRetcode()," ",trade.ResultRetcodeDescription());
      return;
     }

   ulong ticket=trade.ResultOrder();

   // store remaining TP lines for management
   for(int i=0;i<3;i++)
     {
      if(!tpen[i]) continue;
      string name=StringFormat("TP_%I64u_%d",ticket,i+1);
      ObjectCreate(0,name,OBJ_HLINE,0,0,tpvals[i]);
      ObjectSetInteger(0,name,OBJPROP_HIDDEN,true);
     }
   if(sl>0)
     {
      string name=StringFormat("SL_%I64u",ticket);
      ObjectCreate(0,name,OBJ_HLINE,0,0,sl);
      ObjectSetInteger(0,name,OBJPROP_HIDDEN,true);
     }
  }

//+------------------------------------------------------------------+
void ManagePositions()
  {
   for(int i=PositionsTotal()-1;i>=0;i--)
     {
      ulong ticket=PositionGetTicket(i);
      if(ticket==0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC)!=InpMagicNumber) continue;
      double entry=PositionGetDouble(POSITION_PRICE_OPEN);
      double volume=PositionGetDouble(POSITION_VOLUME);
      ENUM_POSITION_TYPE position_type=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      bool isBuy=position_type==POSITION_TYPE_BUY;

      // handle partial TPs
      double tp_levels[3]={0,0,0};
      bool   tpen[3]={TP1_Enable,TP2_Enable,TP3_Enable};
      ENUM_TP_MODE tpmodes[3]={TP1_Mode,TP2_Mode,TP3_Mode};
      double tpinputs[3]={TP1_Value,TP2_Value,TP3_Value};
      double perc[3]={TP1_ClosePercent,TP2_ClosePercent,TP3_ClosePercent};
      double sl=PositionGetDouble(POSITION_SL);
      double pip=PIP();
      double risk=MathAbs(entry-sl)/pip;

      for(int j=0;j<3;j++)
        {
         if(!tpen[j]) continue;
         string name=StringFormat("TP_%I64u_%d",ticket,j+1);
         if(ObjectFind(0,name)>=0) tp_levels[j]=ObjectGetDouble(0,name,OBJPROP_PRICE,0);
        }

      for(int j=0;j<3;j++)
        {
         if(!tpen[j]) continue;
         double price=SymbolInfoDouble(_Symbol, isBuy? SYMBOL_BID: SYMBOL_ASK);
         if((isBuy && price>=tp_levels[j] && tp_levels[j]>0) || (!isBuy && price<=tp_levels[j] && tp_levels[j]>0))
           {
            double close_vol=volume*(perc[j]/100.0);
            if(close_vol>volume) close_vol=volume;
            if(trade.PositionClosePartial(ticket,close_vol))
              {
               Print("TP",j+1," hit");
               ObjectDelete(0,StringFormat("TP_%I64u_%d",ticket,j+1));
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
void DrawSessionBox(int idx)
  {
   if(ObjectFind(0,sessions[idx].obj_name)>=0) ObjectDelete(0,sessions[idx].obj_name);
   ObjectCreate(0,sessions[idx].obj_name,OBJ_RECTANGLE,0,sessions[idx].start_time,sessions[idx].low,sessions[idx].end_time,sessions[idx].high);
   ObjectSetInteger(0,sessions[idx].obj_name,OBJPROP_COLOR,clrDodgerBlue);
   ObjectSetInteger(0,sessions[idx].obj_name,OBJPROP_BACK,true);
  }

//+------------------------------------------------------------------+
double GetATR(int period,ENUM_TIMEFRAMES tf)
  {
   double atr[];
   if(CopyBuffer(iATR(_Symbol,tf,period),0,0,1,atr)<=0) return 0;
   return atr[0];
  }

//+------------------------------------------------------------------+
double RoundLevel(double price,double step,bool up)
  {
   if(step<=0) return price;
   double pips=(price)/step;
   if(up) pips=MathCeil(pips); else pips=MathFloor(pips);
   return pips*step;
  }

//+------------------------------------------------------------------+
void ApplyBreakeven()
  {
   for(int i=PositionsTotal()-1;i>=0;i--)
     {
      ulong ticket=PositionGetTicket(i);
      if(ticket==0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC)!=InpMagicNumber) continue;
      double sl=PositionGetDouble(POSITION_SL);
      double entry=PositionGetDouble(POSITION_PRICE_OPEN);
      ENUM_POSITION_TYPE position_type=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      bool isBuy=position_type==POSITION_TYPE_BUY;
      double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
      double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      double price=isBuy? bid:ask;
      double pip=PIP();
      double risk=MathAbs(entry-sl)/pip;
      bool moved=false;

      if(BE_ByPips)
        {
         double prof=isBuy? (price-entry)/pip : (entry-price)/pip;
         if(prof>=BE_TriggerPips)
           moved=true;
        }
      if(BE_ByR && !moved)
        {
         double prof=isBuy? (price-entry)/pip : (entry-price)/pip;
         if(prof>=BE_TriggerR*risk) moved=true;
        }
      if(!moved && BE_OnTP1)
        {
         string name=StringFormat("TP_%I64u_%d",ticket,1);
         if(ObjectFind(0,name)>=0)
           {
            double tp=ObjectGetDouble(0,name,OBJPROP_PRICE,0);
            if((isBuy && price>=tp) || (!isBuy && price<=tp)) moved=true;
           }
        }
      if(!moved && BE_OnTP2)
        {
         string name=StringFormat("TP_%I64u_%d",ticket,2);
         if(ObjectFind(0,name)>=0)
           {
            double tp=ObjectGetDouble(0,name,OBJPROP_PRICE,0);
            if((isBuy && price>=tp) || (!isBuy && price<=tp)) moved=true;
           }
        }
      if(moved)
        {
         double new_sl=isBuy? entry+BE_BufferPips*pip : entry-BE_BufferPips*pip;
         trade.PositionModify(ticket,new_sl,PositionGetDouble(POSITION_TP));
         Print("Breakeven moved");
        }
     }
  }

//+------------------------------------------------------------------+
void ApplyTrailing()
  {
   if(!UseTrailing) return;
   for(int i=PositionsTotal()-1;i>=0;i--)
     {
      ulong ticket=PositionGetTicket(i);
      if(ticket==0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC)!=InpMagicNumber) continue;
      ENUM_POSITION_TYPE position_type=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      bool isBuy=position_type==POSITION_TYPE_BUY;
      double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
      double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      double price=isBuy? bid:ask;
      double sl=PositionGetDouble(POSITION_SL);
      double entry=PositionGetDouble(POSITION_PRICE_OPEN);
      double pip=PIP();
      bool start=false;
      if(Trail_StartTP1)
        {
         string name=StringFormat("TP_%I64u_%d",ticket,1);
         if(ObjectFind(0,name)>=0)
           {
            double tp=ObjectGetDouble(0,name,OBJPROP_PRICE,0);
            if((isBuy && price>=tp) || (!isBuy && price<=tp)) start=true;
           }
        }
      if(!start)
        {
         double prof=isBuy? (price-entry)/pip : (entry-price)/pip;
         if(prof>=Trail_StartPips) start=true;
        }
      if(start)
        {
         double new_sl=isBuy? price-Trail_DistancePips*pip: price+Trail_DistancePips*pip;
         if((isBuy && new_sl>sl) || (!isBuy && new_sl<sl))
           trade.PositionModify(ticket,new_sl,PositionGetDouble(POSITION_TP));
        }
     }
  }

//+------------------------------------------------------------------+
void TimeExits()
  {
   if(!UseTimeExit) return;
   for(int i=PositionsTotal()-1;i>=0;i--)
     {
      ulong ticket=PositionGetTicket(i);
      if(ticket==0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC)!=InpMagicNumber) continue;
      datetime open=(datetime)PositionGetInteger(POSITION_TIME);
      if(TimeCurrent()-open>=ExitAfterMinutes*60)
        trade.PositionClose(ticket);
     }
  }

//+------------------------------------------------------------------+
void DailyClosures()
  {
   MqlDateTime tm; TimeToStruct(TimeCurrent(),tm);
   bool enable[7]={false,DailyCloseMon,DailyCloseTue,DailyCloseWed,DailyCloseThu,DailyCloseFri,false};
   string times[7]={"00:00",DailyCloseMonTime,DailyCloseTueTime,DailyCloseWedTime,DailyCloseThuTime,DailyCloseFriTime,"00:00"};
   if(!enable[tm.day_of_week]) return;
   long h=StringToInteger(StringSubstr(times[tm.day_of_week],0,2));
   long m=StringToInteger(StringSubstr(times[tm.day_of_week],3,2));
   datetime close_time=StructToTime(tm) - tm.hour*3600 - tm.min*60 - tm.sec + h*3600 + m*60;
   if(TimeCurrent()>=close_time)
     {
      for(int i=PositionsTotal()-1;i>=0;i--)
        {
         ulong ticket=PositionGetTicket(i);
         if(ticket==0) continue;
         if(!PositionSelectByTicket(ticket)) continue;
         if(PositionGetInteger(POSITION_MAGIC)!=InpMagicNumber) continue;
         trade.PositionClose(ticket);
        }
     }
  }

//+------------------------------------------------------------------+
