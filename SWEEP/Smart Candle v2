#property copyright ""
#property link      ""
#property version   "1.00"
#property strict

#include <Trade\Trade.mqh>
#include <Object.mqh>
#include <StdLibErr.mqh>
// #include <OrderInfo.mqh>
// #include <HistoryOrderInfo.mqh>
// #include <PositionInfo.mqh>
// #include <DealInfo.mqh>
// #include <Calendar\Calendar.mqh>

//--- enumerations
enum ENUM_SL_MODE
  {
   SL_MODE_FIXED_PIPS = 0,
   SL_MODE_DECISIVE_CANDLE,
   SL_MODE_ATR_SAME_TF,
   SL_MODE_SWING_POINTS,
   SL_MODE_ATR_CUSTOM_TF
  };

enum ENUM_TP_MODE
  {
   TP_MODE_FIXED_PIPS = 0,
   TP_MODE_ATR
  };

enum ENUM_RISK_MODE
  {
   RISK_MODE_FIXED_LOT = 0,
   RISK_MODE_PERCENT_BALANCE
  };

//--- inputs
input ulong            InpMagicNumber          = 20231117;     // Magic number
input ENUM_TIMEFRAMES  InpDecisiveTimeframe    = PERIOD_H1;    // Timeframe for decisive candle
input int              InpCloseHour            = 8;            // Decisive candle close hour (broker time)
input int              InpCloseMinute          = 0;            // Decisive candle close minute (broker time)
input bool             InpTradeMonday          = true;         // Allow trading on Monday
input bool             InpTradeTuesday         = true;         // Allow trading on Tuesday
input bool             InpTradeWednesday       = true;         // Allow trading on Wednesday
input bool             InpTradeThursday        = true;         // Allow trading on Thursday
input bool             InpTradeFriday          = true;         // Allow trading on Friday
input int              InpMaxSlippage          = 10;           // Slippage in points

//--- stop-loss
input ENUM_SL_MODE     InpStopLossMode         = SL_MODE_DECISIVE_CANDLE; // Stop-loss mode
input double           InpFixedSLPips          = 50.0;         // Fixed stop-loss in pips
input int              InpATRPeriod            = 14;           // ATR period
input double           InpATRSLMultiplier      = 1.5;          // ATR multiplier for stop-loss
input ENUM_TIMEFRAMES  InpATRCustomTimeframe   = PERIOD_D1;    // Custom timeframe for ATR stop
input int              InpSwingLookback        = 5;            // Swing lookback bars

//--- take-profit
input ENUM_TP_MODE     InpTakeProfitMode       = TP_MODE_FIXED_PIPS; // Take-profit mode
input double           InpFixedTPPips          = 100.0;        // Fixed take-profit in pips
input double           InpATRTPMultiplier      = 1.0;          // ATR multiplier for take-profit

//--- position sizing
input ENUM_RISK_MODE   InpRiskMode             = RISK_MODE_FIXED_LOT; // Position sizing mode
input double           InpFixedLotSize         = 0.10;         // Fixed lot size
input double           InpRiskPercent          = 1.0;          // Risk percent (per trade)

//--- news filter inputs
input bool             InpUseNewsFilter        = false;        // Enable news filter
input int              InpNewsBlockBeforeMin   = 30;           // Minutes before news to block entries
input int              InpNewsBlockAfterMin    = 30;           // Minutes after news to block entries
input bool             InpHighImpactNewsOnly   = true;         // Block only high impact news

//--- trade object
CTrade                 trade;

//--- structures
struct SDecisiveCandle
  {
   bool      valid;
   datetime  day_start;
   datetime  open_time;
   datetime  close_time;
   int       direction;   // 1 buy, -1 sell
   int       shift;
   double    open;
   double    high;
   double    low;
   double    close;
  };

//--- globals
SDecisiveCandle g_decisive = {false};
datetime        g_lastSignalDay = 0;
datetime        g_lastTradeDay  = 0;
int             g_atrHandleDecisive = INVALID_HANDLE;
int             g_atrHandleCustom   = INVALID_HANDLE;

//--- helper declarations
bool     EvaluateDailySignal();
void     TryPlaceTrade();
bool     IsTradingDay(int day_of_week);
bool     CalculateStopLoss(const int direction,const double entry,double &sl_price);
bool     CalculateTakeProfit(const int direction,const double entry,double &tp_price);
double   CalculateLotSize(const int direction,const double entry,const double sl);
bool     TradeAlreadyPlaced(const datetime day_start);
datetime GetDayStart(const datetime when);
double   PipValue();
bool     GetATRValue(const int handle,const int shift,double &atr_value);
int      GetATRShift(const ENUM_TIMEFRAMES timeframe,const datetime reference_time);
bool     CheckNewsBlock();
void     UpdateLastTradeDayFromHistory();
double   NormalizeVolumeToSymbol(double volume);
bool     ValidateStops(const int direction,const double entry,const double sl,const double tp);
double   GetSwingPrice(const int direction);

//+------------------------------------------------------------------+
//| Expert initialization                                            |
//+------------------------------------------------------------------+
int OnInit()
  {
   trade.SetExpertMagicNumber((int)InpMagicNumber);
   trade.SetDeviationInPoints(InpMaxSlippage);

   g_atrHandleDecisive = iATR(_Symbol,InpDecisiveTimeframe,InpATRPeriod);
   if(g_atrHandleDecisive == INVALID_HANDLE)
     {
      Print("Smart Candle V2: failed to create ATR handle for decisive timeframe");
      return(INIT_FAILED);
     }

   g_atrHandleCustom = iATR(_Symbol,InpATRCustomTimeframe,InpATRPeriod);
   if(g_atrHandleCustom == INVALID_HANDLE)
     {
      Print("Smart Candle V2: failed to create ATR handle for custom timeframe");
      return(INIT_FAILED);
     }

   UpdateLastTradeDayFromHistory();

   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   if(g_atrHandleDecisive != INVALID_HANDLE)
      IndicatorRelease(g_atrHandleDecisive);
   if(g_atrHandleCustom != INVALID_HANDLE)
      IndicatorRelease(g_atrHandleCustom);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   if(EvaluateDailySignal())
      TryPlaceTrade();
  }

//+------------------------------------------------------------------+
//| Evaluate signal once per day                                     |
//+------------------------------------------------------------------+
bool EvaluateDailySignal()
  {
   datetime now_time = TimeCurrent();
   datetime day_start = GetDayStart(now_time);

   datetime decision_time = day_start + InpCloseHour * 3600 + InpCloseMinute * 60;
   if(now_time < decision_time)
      return(false);

   if(g_lastSignalDay == day_start)
      return(false);

   g_lastSignalDay = day_start;
   g_decisive.valid = false;

   int shift = iBarShift(_Symbol,InpDecisiveTimeframe,decision_time - 1);
   if(shift < 0)
     {
      Print("Smart Candle V2: decisive candle not ready");
      return(false);
     }

   double open_price  = iOpen(_Symbol,InpDecisiveTimeframe,shift);
   double close_price = iClose(_Symbol,InpDecisiveTimeframe,shift);
   double high_price  = iHigh(_Symbol,InpDecisiveTimeframe,shift);
   double low_price   = iLow(_Symbol,InpDecisiveTimeframe,shift);

   int direction = 0;
   if(close_price > open_price)
      direction = 1;
   else if(close_price < open_price)
      direction = -1;

   g_decisive.day_start = day_start;
   g_decisive.open_time = iTime(_Symbol,InpDecisiveTimeframe,shift);
   g_decisive.close_time = g_decisive.open_time + PeriodSeconds(InpDecisiveTimeframe);
   g_decisive.open = open_price;
   g_decisive.close = close_price;
   g_decisive.high = high_price;
   g_decisive.low = low_price;
   g_decisive.direction = direction;
   g_decisive.shift = shift;
   g_decisive.valid = (direction != 0);

   if(!g_decisive.valid)
     {
      Print("Smart Candle V2: Doji candle - no signal for today");
      return(false);
     }

   return(true);
  }

//+------------------------------------------------------------------+
//| Try to open the daily trade                                      |
//+------------------------------------------------------------------+
void TryPlaceTrade()
  {
   if(!g_decisive.valid)
      return;

   // we komen hier alleen als alle eerdere checks geslaagd zijn

   datetime day_start = g_decisive.day_start;

   // controleer of deze dag toegestaan is
   if(!IsTradingDay(TimeDayOfWeek(day_start)))
     {
      Print("Smart Candle V2: trading disabled for this day");
      return;
     }

   // controleer of er al een trade is geplaatst op deze dag
   if(TradeAlreadyPlaced(day_start))
     {
      Print("Smart Candle V2: daily trade already executed");
      return;
     }

   // nieuwsfilter check
   if(InpUseNewsFilter && CheckNewsBlock())
     {
      Print("Smart Candle V2: blocked by news filter");
      return;
     }

   RefreshRates();
   double entry_price = (g_decisive.direction > 0)
                        ? SymbolInfoDouble(_Symbol,SYMBOL_ASK)
                        : SymbolInfoDouble(_Symbol,SYMBOL_BID);

   double sl_price = 0.0;
   double tp_price = 0.0;
   if(!CalculateStopLoss(g_decisive.direction,entry_price,sl_price))
     {
      Print("Smart Candle V2: failed to calculate stop-loss");
      return;
     }

   if(!CalculateTakeProfit(g_decisive.direction,entry_price,tp_price))
     {
      Print("Smart Candle V2: failed to calculate take-profit");
      return;
     }

   if(!ValidateStops(g_decisive.direction,entry_price,sl_price,tp_price))
     {
      Print("Smart Candle V2: stop levels too close");
      return;
     }

   double lot_size = CalculateLotSize(g_decisive.direction,entry_price,sl_price);
   if(lot_size <= 0.0)
     {
      Print("Smart Candle V2: invalid lot size");
      return;
     }

   bool trade_result = false;
   string comment = "SmartCandleV2";

   if(g_decisive.direction > 0)
      trade_result = trade.Buy(lot_size,_Symbol,entry_price,sl_price,tp_price,comment);
   else
      trade_result = trade.Sell(lot_size,_Symbol,entry_price,sl_price,tp_price,comment);

   if(trade_result)
     {
      g_lastTradeDay = day_start;
      Print("Smart Candle V2: trade placed successfully");
     }
   else
     {
      PrintFormat("Smart Candle V2: trade placement failed, error %d",GetLastError());
     }
  }

//+------------------------------------------------------------------+
//| Check trading day filter                                         |
//+------------------------------------------------------------------+
bool IsTradingDay(int day_of_week)
  {
   switch(day_of_week)
     {
      case 1: return(InpTradeMonday);
      case 2: return(InpTradeTuesday);
      case 3: return(InpTradeWednesday);
      case 4: return(InpTradeThursday);
      case 5: return(InpTradeFriday);
      default: return(false);
     }
  }

//+------------------------------------------------------------------+
//| Compute stop-loss                                                |
//+------------------------------------------------------------------+
bool CalculateStopLoss(const int direction,const double entry,double &sl_price)
  {
   double pip = PipValue();
   switch(InpStopLossMode)
     {
      case SL_MODE_FIXED_PIPS:
         {
          double distance = InpFixedSLPips * pip;
          if(distance <= 0.0)
             return(false);
          sl_price = (direction > 0) ? entry - distance : entry + distance;
          break;
         }
      case SL_MODE_DECISIVE_CANDLE:
         {
          sl_price = (direction > 0) ? g_decisive.low : g_decisive.high;
          break;
         }
      case SL_MODE_ATR_SAME_TF:
         {
          double atr = 0.0;
          if(!GetATRValue(g_atrHandleDecisive,g_decisive.shift,atr))
             return(false);
          double distance = atr * InpATRSLMultiplier;
          sl_price = (direction > 0) ? entry - distance : entry + distance;
          break;
         }
      case SL_MODE_SWING_POINTS:
         {
          double swing_price = GetSwingPrice(direction);
          if(swing_price <= 0.0)
             return(false);
          sl_price = swing_price;
          break;
         }
      case SL_MODE_ATR_CUSTOM_TF:
         {
          int shift = GetATRShift(InpATRCustomTimeframe,g_decisive.close_time);
          if(shift < 0)
             return(false);
          double atr = 0.0;
          if(!GetATRValue(g_atrHandleCustom,shift,atr))
             return(false);
          double distance = atr * InpATRSLMultiplier;
          sl_price = (direction > 0) ? entry - distance : entry + distance;
          break;
         }
      default:
         return(false);
     }

   if(sl_price <= 0.0)
      return(false);

   return(true);
  }

//+------------------------------------------------------------------+
//| Compute take-profit                                              |
//+------------------------------------------------------------------+
bool CalculateTakeProfit(const int direction,const double entry,double &tp_price)
  {
   double pip = PipValue();
   switch(InpTakeProfitMode)
     {
      case TP_MODE_FIXED_PIPS:
         {
          double distance = InpFixedTPPips * pip;
          if(distance <= 0.0)
             return(false);
          tp_price = (direction > 0) ? entry + distance : entry - distance;
          break;
         }
      case TP_MODE_ATR:
         {
          double atr = 0.0;
          if(!GetATRValue(g_atrHandleDecisive,g_decisive.shift,atr))
             return(false);
          double distance = atr * InpATRTPMultiplier;
          tp_price = (direction > 0) ? entry + distance : entry - distance;
          break;
         }
      default:
         return(false);
     }

   if(tp_price <= 0.0)
      return(false);

   return(true);
  }

//+------------------------------------------------------------------+
//| Position sizing                                                  |
//+------------------------------------------------------------------+
double CalculateLotSize(const int direction,const double entry,const double sl)
  {
   if(InpRiskMode == RISK_MODE_FIXED_LOT)
      return(NormalizeVolumeToSymbol(InpFixedLotSize));

   double distance = MathAbs(entry - sl);
   if(distance <= 0.0)
      return(0.0);

   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double risk_amount = balance * InpRiskPercent / 100.0;
   if(risk_amount <= 0.0)
      return(0.0);

   double tick_value = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tick_size  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
   if(tick_value <= 0.0 || tick_size <= 0.0)
      return(0.0);

   double loss_per_lot = (distance / tick_size) * tick_value;
   if(loss_per_lot <= 0.0)
      return(0.0);

   double volume = risk_amount / loss_per_lot;
   return(NormalizeVolumeToSymbol(volume));
  }

//+------------------------------------------------------------------+
//| Normalize volume                                                 |
//+------------------------------------------------------------------+
double NormalizeVolumeToSymbol(double volume)
  {
   double min_lot  = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double max_lot  = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double lot_step = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);

   if(lot_step <= 0.0)
      lot_step = 0.01;

   // clamp naar min/max
   volume = MathMax(min_lot,MathMin(max_lot,volume));

   // afronden op lot_step
   volume = MathFloor(volume / lot_step + 0.5) * lot_step;

   // digits afleiden uit lot_step, bijv. 0.01 -> 2 digits
   int vol_digits = 0;
   double tmp = lot_step;
   while(tmp < 1.0 && vol_digits < 8)
     {
      tmp *= 10.0;
      vol_digits++;
     }

   return(NormalizeDouble(volume,vol_digits));
  }

//+------------------------------------------------------------------+
//| Verify one-trade-per-day rule                                    |
//+------------------------------------------------------------------+
bool TradeAlreadyPlaced(const datetime day_start)
  {
   if(g_lastTradeDay == day_start)
      return(true);

   for(int i = PositionsTotal() - 1; i >= 0; --i)
     {
      if(!PositionSelectByIndex(i))
         continue;
      string symbol = PositionGetString(POSITION_SYMBOL);
      ulong magic = (ulong)PositionGetInteger(POSITION_MAGIC);
      if(symbol != _Symbol || magic != InpMagicNumber)
         continue;
      datetime open_time = (datetime)PositionGetInteger(POSITION_TIME);
      if(open_time >= day_start)
         return(true);
     }

   return(false);
  }

//+------------------------------------------------------------------+
//| Helper: get day start                                            |
//+------------------------------------------------------------------+
datetime GetDayStart(const datetime when)
  {
   MqlDateTime dt;
   TimeToStruct(when,dt);
   dt.hour = 0;
   dt.min = 0;
   dt.sec = 0;
   return(StructToTime(dt));
  }

//+------------------------------------------------------------------+
//| Helper: pip value                                                |
//+------------------------------------------------------------------+
double PipValue()
  {
   int digits = (int)SymbolInfoInteger(_Symbol,SYMBOL_DIGITS);
   if(digits == 3 || digits == 5)
      return(10.0 * _Point);
   return(_Point);
  }

//+------------------------------------------------------------------+
//| Helper: ATR value                                                |
//+------------------------------------------------------------------+
bool GetATRValue(const int handle,const int shift,double &atr_value)
  {
   if(handle == INVALID_HANDLE)
      return(false);
   double buffer[1];
   if(CopyBuffer(handle,0,shift,1,buffer) <= 0)
      return(false);
   atr_value = buffer[0];
   return(atr_value > 0.0);
  }

//+------------------------------------------------------------------+
//| Helper: ATR shift                                                |
//+------------------------------------------------------------------+
int GetATRShift(const ENUM_TIMEFRAMES timeframe,const datetime reference_time)
  {
   int shift = iBarShift(_Symbol,timeframe,reference_time - 1);
   return(shift);
  }

//+------------------------------------------------------------------+
//| News filter                                                      |
//+------------------------------------------------------------------+
bool CheckNewsBlock()
  {
   // Als de nieuwsfilter uit staat: nooit blokken
   if(!InpUseNewsFilter)
      return(false);

   // LET OP:
   // De Calendar API (MqlCalendarEvent, CalendarEventByFilter, enz.)
   // is niet beschikbaar op deze terminal / VPS.
   // Daarom is deze functie nu een 'stub' en blokkeert hij geen trades.
   //
   // De inputs InpUseNewsFilter, InpNewsBlockBeforeMin, InpNewsBlockAfterMin
   // en InpHighImpactNewsOnly blijven bestaan, maar worden hier niet gebruikt.
   // Later kan ik dit zelf weer uitbreiden als Calendar.mqh beschikbaar is.

   return(false);
  }

//+------------------------------------------------------------------+
//| Update last trade day from history                               |
//+------------------------------------------------------------------+
void UpdateLastTradeDayFromHistory()
  {
   datetime now_time = TimeCurrent();
   datetime from_time = now_time - 86400 * 180; // look back ~6 months
   if(!HistorySelect(from_time,now_time))
      return;

   int deals = HistoryDealsTotal();
   for(int i = deals - 1; i >= 0; --i)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket == 0)
         continue;
      string symbol = HistoryDealGetString(ticket,DEAL_SYMBOL);
      ulong magic   = (ulong)HistoryDealGetInteger(ticket,DEAL_MAGIC);
      if(symbol != _Symbol || magic != InpMagicNumber)
         continue;
      ENUM_DEAL_ENTRY entry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(ticket,DEAL_ENTRY);
      if(entry != DEAL_ENTRY_IN)
         continue;
      datetime time_entry = (datetime)HistoryDealGetInteger(ticket,DEAL_TIME);
      datetime day_start = GetDayStart(time_entry);
      if(day_start > g_lastTradeDay)
         g_lastTradeDay = day_start;
      break;
     }
  }

//+------------------------------------------------------------------+
//| Validate stop levels                                             |
//+------------------------------------------------------------------+
bool ValidateStops(const int direction,const double entry,const double sl,const double tp)
  {
   int stops_level = (int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);
   double min_distance = stops_level * _Point;

   if(min_distance <= 0.0)
      return(true);

   if(direction > 0)
     {
      if(sl > 0.0 && (entry - sl) < min_distance)
         return(false);
      if(tp > 0.0 && (tp - entry) < min_distance)
         return(false);
     }
   else
     {
      if(sl > 0.0 && (sl - entry) < min_distance)
         return(false);
      if(tp > 0.0 && (entry - tp) < min_distance)
         return(false);
     }

   return(true);
  }

//+------------------------------------------------------------------+
//| Swing high/low helper                                            |
//+------------------------------------------------------------------+
double GetSwingPrice(const int direction)
  {
   if(InpSwingLookback <= 0)
      return(0.0);

   if(direction > 0)
     {
      int index = iLowest(_Symbol,InpDecisiveTimeframe,MODE_LOW,InpSwingLookback,g_decisive.shift);
      if(index < 0)
         return(0.0);
      return(iLow(_Symbol,InpDecisiveTimeframe,index));
     }
   else
     {
      int index = iHighest(_Symbol,InpDecisiveTimeframe,MODE_HIGH,InpSwingLookback,g_decisive.shift);
      if(index < 0)
         return(0.0);
      return(iHigh(_Symbol,InpDecisiveTimeframe,index));
     }
  }
