//+------------------------------------------------------------------+
//|                                              SmartCandleV2.mq5   |
//|                       MQL5 Expert Advisor implementing the       |
//|                       "Smart Candle V2" strategy.                |
//|                                                                  |
//|  This EA reads a decisive candle on a user‑specified timeframe   |
//|  at a specific closing time and opens a trade on the next bar    |
//|  based on the candle's direction.  Various stop‑loss and take‑   |
//|  profit methods are supported, including fixed, ATR‑based and     |
//|  swing high/low approaches.  Risk management can use a fixed     |
//|  lot size or a dynamic lot calculated from the account balance   |
//|  and distance to the stop loss.  The code uses the CTrade class  |
//|  of the standard library to send trade requests.  ATR indicator  |
//|  values are obtained via indicator handles and CopyBuffer() as    |
//|  required by MQL5【718389191056773†L83-L113】.                       |
//|                                                                  |
//|  NOTE: This EA is provided for educational purposes and should   |
//|  be tested on a demo account before live trading.                |
//+------------------------------------------------------------------+

#property strict
#property version   "2.0"
#property description "Smart Candle V2 Expert Advisor (MQL5)"

// Include trade class for order operations
#include <Trade\Trade.mqh>

//---- input parameters ---------------------------------------------------
input int              MagicNumber         = 20231117;    // Magic number for identification
input ENUM_TIMEFRAMES  DecisionTimeframe   = PERIOD_H1;    // Timeframe of the decisive candle
input string           DecisionTime        = "04:00";     // Closing time of decisive candle (HH:MM server time)

//---- day of week filter: Sunday=0 ... Saturday=6 -----------------------
input bool             AllowMonday         = true;        // Trade on Monday
input bool             AllowTuesday        = true;        // Trade on Tuesday
input bool             AllowWednesday      = true;        // Trade on Wednesday
input bool             AllowThursday       = true;        // Trade on Thursday
input bool             AllowFriday         = true;        // Trade on Friday

input bool             UseOneTradePerDay   = true;        // Enforce one trade per day
input bool             UseNewsFilter       = false;       // Placeholder for news filter (not implemented)

//---- HTF EMA trend filter (entry gate) -------------------------------
input bool             UseHTF_EMA_Filter   = false;      // Enable HTF EMA filter for entries
input ENUM_TIMEFRAMES  TrendEMA_TF         = PERIOD_H4;  // Timeframe for HTF trend EMAs
input int              TrendEMA_Fast       = 40;         // Fast EMA period
input int              TrendEMA_Slow       = 50;         // Slow EMA period

//---- stop loss options --------------------------------------------------
enum StopLossMethod
  {
   SL_Fixed        = 0,   // Fixed stop loss in pips
   SL_CandleRange  = 1,   // Use high/low of decisive candle
   SL_ATR_Old      = 2,   // ATR stop loss using same timeframe
   SL_Swing        = 3,   // Swing high/low based stop loss
   SL_ATR_Custom   = 4    // ATR stop loss using custom timeframe
  };

input StopLossMethod SL_Method       = SL_Fixed;
input double         FixedSLPips     = 50.0;       // Pips for fixed SL
input int            ATR_SL_Period   = 14;         // ATR period for old method
input double         ATR_SL_Mult     = 1.0;        // ATR multiplier for old method
input int            SwingLookback   = 5;          // Lookback bars for swing SL
input int            ATR_Custom_Per  = 14;         // ATR period for custom timeframe
input double         ATR_Custom_Mult = 1.0;        // ATR multiplier for custom timeframe
input ENUM_TIMEFRAMES ATR_Custom_TF  = PERIOD_H4;  // ATR timeframe for custom SL

//---- take profit options -------------------------------------------------
enum TakeProfitMethod
  {
   TP_Fixed   = 0,  // Fixed take profit in pips
   TP_ATR     = 1   // ATR based take profit (same timeframe)
  };

input TakeProfitMethod TP_Method      = TP_Fixed;
input double           FixedTPPips    = 100.0;      // Pips for fixed TP
input int              ATR_TP_Period  = 14;         // ATR period for TP
input double           ATR_TP_Mult    = 2.0;        // ATR multiplier for TP

//---- risk management options --------------------------------------------
enum RiskMethod
  {
   RM_FixedLot = 0,      // Always trade fixed lot size
   RM_RiskPct  = 1       // Risk a percentage of account balance
  };

input RiskMethod        RM_Method      = RM_FixedLot;
input double            FixedLotSize   = 0.10;      // Fixed lot size when RM_FixedLot
input double            RiskPercent    = 1.0;       // Percentage of balance to risk per trade (0..100)

//---- exit modules -------------------------------------------------------
input bool              UseTimeExit         = false;                 // Enable time-based exit
input int               MaxTradeMinutes     = 0;                     // Max trade duration (minutes); 0 disables
input bool              EnableExitLogging   = false;                 // Enable exit logging to CSV
input string            ExitLogFile         = "SmartCandleV2_ExitLog.csv"; // Exit log file name

//---- internal state variables ------------------------------------------
int     g_decisionMinutes     = 0;        // Minutes after midnight for decisive candle close
datetime g_lastBarTime        = 0;        // Last processed bar time on DecisionTimeframe
int     g_lastTradeDayOfYear  = -1;       // Day of year of the last trade (for one trade per day)

// ATR indicator handles (created on demand)
int atrHandleSL  = INVALID_HANDLE;        // Handle for ATR used in stop loss (old method)
int atrHandleTP  = INVALID_HANDLE;        // Handle for ATR used in take profit
int atrHandleCustomSL = INVALID_HANDLE;   // Handle for custom timeframe ATR for stop loss

// Trend EMA handles for entry filter
int trendEmaFastHandle = INVALID_HANDLE;
int trendEmaSlowHandle = INVALID_HANDLE;

// Trade object
CTrade trade;

//+------------------------------------------------------------------+
//| Parse the HH:MM decision time string to minutes after midnight   |
//+------------------------------------------------------------------+
int ParseDecisionMinutes(const string timeStr)
  {
   int colonPos = StringFind(timeStr, ":");
   if(colonPos > 0)
     {
      string hh = StringSubstr(timeStr, 0, colonPos);
      string mm = StringSubstr(timeStr, colonPos + 1);
      int hour  = (int)StringToInteger(hh);
      int minute= (int)StringToInteger(mm);
      return(hour * 60 + minute);
     }
   return(0);
  }

//+------------------------------------------------------------------+
//| Indicator value fetcher for ATR                                  |
//| Fetches the ATR value at the given shift (start_pos) from the    |
//| indicator handle using CopyBuffer()【573739094363470†L76-L120】.             |
//+------------------------------------------------------------------+
double GetATR(int handle, int shift)
  {
   if(handle == INVALID_HANDLE)
      return(0.0);
   double buffer[];
   ArraySetAsSeries(buffer, true);
   // Copy one value at the specified shift
   int copied = CopyBuffer(handle, 0, shift, 1, buffer);
   if(copied == 1)
      return(buffer[0]);
   return(0.0);
  }

//+------------------------------------------------------------------+
//| Indicator value fetcher for EMA                                  |
//+------------------------------------------------------------------+
double GetEMA(int handle, int shift)
  {
   if(handle == INVALID_HANDLE)
      return(0.0);
   double buffer[];
   ArraySetAsSeries(buffer, true);
   int copied = CopyBuffer(handle, 0, shift, 1, buffer);
   if(copied == 1)
      return(buffer[0]);
   return(0.0);
  }

//+------------------------------------------------------------------+
//| Check if trading is allowed on the given day of week             |
//+------------------------------------------------------------------+
bool DayAllowed(int dayOfWeek)
  {
   // dayOfWeek: 0=Sunday, 1=Monday, ..., 6=Saturday
   if(dayOfWeek == 1 && AllowMonday)        return(true);
   if(dayOfWeek == 2 && AllowTuesday)       return(true);
   if(dayOfWeek == 3 && AllowWednesday)     return(true);
   if(dayOfWeek == 4 && AllowThursday)      return(true);
   if(dayOfWeek == 5 && AllowFriday)        return(true);
   return(false); // Weekends not allowed
  }

//+------------------------------------------------------------------+
//| Placeholder for news filter. Returns false if not blocked.       |
//+------------------------------------------------------------------+
bool NewsBlocked()
  {
   if(!UseNewsFilter)
      return(false);
   // Real news filtering would require external data. Not implemented.
   return(false);
  }

//+------------------------------------------------------------------+
//| Determine HTF EMA trend permissions for entries                  |
//+------------------------------------------------------------------+
bool GetHTFTrendPermissions(bool &buyAllowed, bool &sellAllowed)
  {
   buyAllowed = true;
   sellAllowed = true;
   if(!UseHTF_EMA_Filter)
      return(true);

   if(trendEmaFastHandle == INVALID_HANDLE || trendEmaSlowHandle == INVALID_HANDLE)
     {
      buyAllowed = false;
      sellAllowed = false;
      Print("HTF EMA filter handles are invalid.");
      return(false);
     }

   double emaFast = GetEMA(trendEmaFastHandle, 1);
   double emaSlow = GetEMA(trendEmaSlowHandle, 1);
   if(emaFast == 0.0 || emaSlow == 0.0)
     {
      buyAllowed = false;
      sellAllowed = false;
      Print("HTF EMA filter data unavailable.");
      return(false);
     }

   if(emaFast > emaSlow)
     {
      buyAllowed = true;
      sellAllowed = false;
     }
   else if(emaFast < emaSlow)
     {
      buyAllowed = false;
      sellAllowed = true;
     }
   else
     {
      buyAllowed = false;
      sellAllowed = false;
     }
   return(true);
  }

//+------------------------------------------------------------------+
//| Check time-based exit                                            |
//+------------------------------------------------------------------+
bool IsTimeExitTriggered(ulong ticket, int maxMinutes, int &durationMin)
  {
   durationMin = 0;
   if(!UseTimeExit || maxMinutes <= 0)
      return(false);
   if(!PositionSelectByTicket(ticket))
      return(false);
   datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
   int elapsed = (int)((TimeCurrent() - openTime) / 60);
   durationMin = elapsed;
   if(elapsed >= maxMinutes)
      return(true);
   return(false);
  }

//+------------------------------------------------------------------+
//| Log exit to CSV                                                  |
//+------------------------------------------------------------------+
void LogExitToCSV(const string reason,
                  const string symbol,
                  const ulong ticket,
                  const long positionType,
                  const double volume,
                  const datetime openTime,
                  const datetime closeTime,
                  const int durationMin,
                  const double openPrice,
                  const double closePrice,
                  const double profit)
  {
   if(!EnableExitLogging)
      return;
   int file = FileOpen(ExitLogFile, FILE_READ | FILE_WRITE | FILE_CSV | FILE_ANSI);
   if(file == INVALID_HANDLE)
     {
      Print("Failed to open exit log file: ", ExitLogFile, " Error=", GetLastError());
      return;
     }
   bool writeHeader = (FileSize(file) == 0);
   FileSeek(file, 0, SEEK_END);
   if(writeHeader)
     {
      FileWrite(file, "timestamp", "symbol", "ticket", "type", "lots", "openTime", "closeTime",
                "durationMin", "openPrice", "closePrice", "profit", "reason");
     }
   string typeStr = (positionType == POSITION_TYPE_BUY ? "BUY" : "SELL");
   FileWrite(file,
             TimeToString(closeTime, TIME_DATE | TIME_SECONDS),
             symbol,
             (long)ticket,
             typeStr,
             DoubleToString(volume, 2),
             TimeToString(openTime, TIME_DATE | TIME_SECONDS),
             TimeToString(closeTime, TIME_DATE | TIME_SECONDS),
             durationMin,
             DoubleToString(openPrice, _Digits),
             DoubleToString(closePrice, _Digits),
             DoubleToString(profit, 2),
             reason);
   FileClose(file);
  }

//+------------------------------------------------------------------+
//| Attempt to close a position and log exit reason                  |
//+------------------------------------------------------------------+
bool TryClosePosition(ulong ticket, const string reason, int durationMin)
  {
   if(!PositionSelectByTicket(ticket))
      return(false);

   string symbol = PositionGetString(POSITION_SYMBOL);
   long positionType = PositionGetInteger(POSITION_TYPE);
   double volume = PositionGetDouble(POSITION_VOLUME);
   datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
   double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);

   if(durationMin < 0)
      durationMin = (int)((TimeCurrent() - openTime) / 60);

   trade.SetExpertMagicNumber(MagicNumber);

   bool closed = false;
   for(int attempt = 0; attempt < 2; attempt++)
     {
      if(trade.PositionClose(ticket))
        {
         closed = (trade.ResultRetcode() == TRADE_RETCODE_DONE);
         if(closed)
            break;
        }
     }

   if(!closed)
     {
      Print("Position close failed for ticket ", ticket, ". Retcode=", trade.ResultRetcode(),
            " ", trade.ResultRetcodeDescription());
      return(false);
     }

   datetime closeTime = TimeCurrent();
   double closePrice = trade.ResultPrice();
   double profit = 0.0;
   ulong dealTicket = trade.ResultDeal();
   if(dealTicket > 0)
     {
      if(HistorySelect(openTime, closeTime))
        {
         if(HistoryDealSelect(dealTicket))
           {
            closeTime = (datetime)HistoryDealGetInteger(dealTicket, DEAL_TIME);
            closePrice = HistoryDealGetDouble(dealTicket, DEAL_PRICE);
            profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
           }
        }
     }

   LogExitToCSV(reason, symbol, ticket, positionType, volume, openTime, closeTime,
                durationMin, openPrice, closePrice, profit);
   return(true);
  }

//+------------------------------------------------------------------+
//| Central manager for open positions                               |
//+------------------------------------------------------------------+
void ManageOpenPositions()
  {
   for(int pos = PositionsTotal() - 1; pos >= 0; pos--)
     {
      ulong ticket = PositionGetTicket(pos);
      if(!PositionSelectByTicket(ticket))
         continue;
      long magic = PositionGetInteger(POSITION_MAGIC);
      string sym = PositionGetString(POSITION_SYMBOL);
      if(magic != MagicNumber || sym != _Symbol)
         continue;

      int durationMin = 0;
      if(IsTimeExitTriggered(ticket, MaxTradeMinutes, durationMin))
        {
         if(TryClosePosition(ticket, "TimeExit", durationMin))
            continue;
        }

      // Existing exit modules (lock profit, trailing stop, EMA slope exit)
      // are expected to be evaluated here without more than one close attempt
      // per position per tick. This EA currently has no additional exit logic.
     }
  }

//+------------------------------------------------------------------+
//| Calculates dynamic lot size based on risk percentage.            |
//| Uses symbol properties for tick size, tick value and volume      |
//| limits【777576027852568†L390-L460】.                               |
//+------------------------------------------------------------------+
double CalculateLotSize(double entryPrice, double stopPrice, double riskPct)
  {
   // Return fixed lot if RM is fixed
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount     = accountBalance * riskPct / 100.0;
   double distance       = MathAbs(entryPrice - stopPrice);
   if(distance <= 0.0 || riskAmount <= 0.0)
      return(0.0);
   // Retrieve tick size and tick value for profit or loss
   double tickSize    = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue   = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE); // value per tick
   if(tickSize <= 0.0 || tickValue <= 0.0)
      return(0.0);
   // Convert price distance into ticks
   double ticks       = distance / tickSize;
   // Cost of one lot for the distance
   double costPerLot  = ticks * tickValue;
   if(costPerLot <= 0.0)
      return(0.0);
   // Calculate raw lots
   double lots        = riskAmount / costPerLot;
   return(lots);
  }

//+------------------------------------------------------------------+
//| Normalize lot size to allowed broker constraints                 |
//+------------------------------------------------------------------+
double NormalizeLotSize(double lots)
  {
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep= SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   if(lotStep <= 0.0)
      lotStep = 1.0;
   if(lots < minLot)
      lots = minLot;
   if(lots > maxLot)
      lots = maxLot;
   // Align to volume step
   lots = MathFloor(lots / lotStep) * lotStep;
   return(lots);
  }

//+------------------------------------------------------------------+
//| Opens a market position with computed parameters using CTrade.   |
//| orderType should be ORDER_TYPE_BUY or ORDER_TYPE_SELL.            |
//+------------------------------------------------------------------+
void EnterTrade(int orderType)
  {
   // Refresh the environment
   // Determine entry price as open of current bar on decision timeframe
   double entryPrice = iOpen(_Symbol, DecisionTimeframe, 0);
   if(entryPrice <= 0.0)
      return;

   // Compute stop loss (sl) and take profit (tp)
   double sl = 0.0;
   double tp = 0.0;

   // Fixed SL
   if(SL_Method == SL_Fixed)
     {
      double slDist = FixedSLPips * _Point;
      if(orderType == ORDER_TYPE_BUY)
         sl = entryPrice - slDist;
      else
         sl = entryPrice + slDist;
     }
   else if(SL_Method == SL_CandleRange)
     {
      // Use high/low of decisive candle (index 1)
      double decLow  = iLow(_Symbol, DecisionTimeframe, 1);
      double decHigh = iHigh(_Symbol, DecisionTimeframe, 1);
      if(orderType == ORDER_TYPE_BUY)
         sl = decLow;
      else
         sl = decHigh;
     }
   else if(SL_Method == SL_ATR_Old)
     {
      double atr = GetATR(atrHandleSL, 1);
      double dist = atr * ATR_SL_Mult;
      if(orderType == ORDER_TYPE_BUY)
         sl = entryPrice - dist;
      else
         sl = entryPrice + dist;
     }
   else if(SL_Method == SL_Swing)
     {
      // Swing high/low based on last SwingLookback bars ending at index 1
      if(orderType == ORDER_TYPE_BUY)
        {
         int lowShift = iLowest(_Symbol, DecisionTimeframe, MODE_LOW, SwingLookback, 1);
         sl = iLow(_Symbol, DecisionTimeframe, lowShift);
        }
      else
        {
         int highShift = iHighest(_Symbol, DecisionTimeframe, MODE_HIGH, SwingLookback, 1);
         sl = iHigh(_Symbol, DecisionTimeframe, highShift);
        }
     }
   else if(SL_Method == SL_ATR_Custom)
     {
      double atr = GetATR(atrHandleCustomSL, 1);
      double dist = atr * ATR_Custom_Mult;
      if(orderType == ORDER_TYPE_BUY)
         sl = entryPrice - dist;
      else
         sl = entryPrice + dist;
     }

   // Take profit
   if(TP_Method == TP_Fixed)
     {
      double tpDist = FixedTPPips * _Point;
      if(orderType == ORDER_TYPE_BUY)
         tp = entryPrice + tpDist;
      else
         tp = entryPrice - tpDist;
     }
   else if(TP_Method == TP_ATR)
     {
      double atr = GetATR(atrHandleTP, 1);
      double dist = atr * ATR_TP_Mult;
      if(orderType == ORDER_TYPE_BUY)
         tp = entryPrice + dist;
      else
         tp = entryPrice - dist;
     }

   // Determine lot size
   double lots;
   if(RM_Method == RM_FixedLot)
     {
      lots = FixedLotSize;
     }
   else
     {
      lots = CalculateLotSize(entryPrice, sl, RiskPercent);
     }
   lots = NormalizeLotSize(lots);
   if(lots <= 0.0)
     {
      Print("Lot size calculated as zero. Trade not opened.");
      return;
     }

   // Set slippage/deviation in points (optional). Here 10 points.
   trade.SetDeviationInPoints(10);
   // Set the Magic number for this expert
   trade.SetExpertMagicNumber(MagicNumber);

   bool result;
   if(orderType == ORDER_TYPE_BUY)
     {
      result = trade.Buy(lots, _Symbol, entryPrice, sl, tp, "Smart Candle V2");
     }
   else
     {
      result = trade.Sell(lots, _Symbol, entryPrice, sl, tp, "Smart Candle V2");
     }
   if(!result)
     {
      // Failed to send trade request
      Print("OrderSend failed: ", trade.ResultRetcode(), " ", trade.ResultRetcodeDescription());
      return;
     }
   // If trade request accepted, update last trade day for one trade per day
   if(trade.ResultRetcode() == TRADE_RETCODE_DONE)
     {
      /*
         In MQL5 there is no TimeDayOfYear() function (it exists in MQL4 only).
         To obtain the day-of-year value, convert the current server time to an
         MqlDateTime structure using TimeToStruct().  The structure field
         day_of_year contains the day number starting from 0 for January 1st.
      */
      MqlDateTime nowStruct;
      datetime nowTime = TimeCurrent();
      TimeToStruct(nowTime, nowStruct);
      g_lastTradeDayOfYear = nowStruct.day_of_year;
      Print("Trade opened: Ticket=", trade.ResultOrder(), " Type=", orderType,
            " Lots=", lots, " SL=", sl, " TP=", tp);
     }
  }

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   // Parse decision time once
   g_decisionMinutes = ParseDecisionMinutes(DecisionTime);

   // Create ATR handles as needed
   // ATR for stop loss (old method) or TP if same period
   if(SL_Method == SL_ATR_Old || TP_Method == TP_ATR)
     {
      // For old SL we use ATR_SL_Period; for TP we may use ATR_TP_Period
      atrHandleSL = iATR(_Symbol, DecisionTimeframe, ATR_SL_Period);
      if(TP_Method == TP_ATR)
        {
         // If TP uses a different period, create separate handle
         if(ATR_TP_Period != ATR_SL_Period)
            atrHandleTP = iATR(_Symbol, DecisionTimeframe, ATR_TP_Period);
         else
            atrHandleTP = atrHandleSL;
        }
     }
   if(SL_Method == SL_ATR_Custom)
     {
      atrHandleCustomSL = iATR(_Symbol, ATR_Custom_TF, ATR_Custom_Per);
     }
   if(UseHTF_EMA_Filter)
     {
      trendEmaFastHandle = iMA(_Symbol, TrendEMA_TF, TrendEMA_Fast, 0, MODE_EMA, PRICE_CLOSE);
      trendEmaSlowHandle = iMA(_Symbol, TrendEMA_TF, TrendEMA_Slow, 0, MODE_EMA, PRICE_CLOSE);
     }
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   // Release indicator handles
   if(atrHandleSL != INVALID_HANDLE)
      IndicatorRelease(atrHandleSL);
   if(atrHandleTP != INVALID_HANDLE && atrHandleTP != atrHandleSL)
      IndicatorRelease(atrHandleTP);
   if(atrHandleCustomSL != INVALID_HANDLE)
      IndicatorRelease(atrHandleCustomSL);
   if(trendEmaFastHandle != INVALID_HANDLE)
      IndicatorRelease(trendEmaFastHandle);
   if(trendEmaSlowHandle != INVALID_HANDLE)
      IndicatorRelease(trendEmaSlowHandle);
  }

//+------------------------------------------------------------------+
//| Main event handler called on every tick                          |
//+------------------------------------------------------------------+
void OnTick()
  {
   ManageOpenPositions();

   // Check for a new bar on the decision timeframe
   datetime currentBarTime = iTime(_Symbol, DecisionTimeframe, 0);
   if(currentBarTime == g_lastBarTime)
      return;
   g_lastBarTime = currentBarTime;

   // Decisive candle is the previous bar (shift 1)
   datetime decTime = iTime(_Symbol, DecisionTimeframe, 1);
   if(decTime <= 0)
      return;
   // Break down the decisive candle time into its components using TimeToStruct().
   // MqlDateTime contains fields such as hour, min, day_of_week and day_of_year.
   MqlDateTime decStruct;
   TimeToStruct(decTime, decStruct);
   // Combine hour and minute into total minutes after midnight
   int decMinutes = decStruct.hour * 60 + decStruct.min;
   // Ensure the decisive candle closed exactly at the configured time
   if(decMinutes != g_decisionMinutes)
      return;
   // Check day-of-week filter. day_of_week: 0=Sunday, 1=Monday, ..., 6=Saturday
   int dow = decStruct.day_of_week;
   if(!DayAllowed(dow))
      return;
   // Check one trade per day restriction
   if(UseOneTradePerDay)
     {
      int today = decStruct.day_of_year;
      if(today == g_lastTradeDayOfYear)
         return;
      // Also ensure there is no open position on this symbol and magic number
      for(int pos=PositionsTotal()-1; pos>=0; pos--)
        {
         ulong ticket = PositionGetTicket(pos);
         if(PositionSelectByTicket(ticket))
           {
            long magic = PositionGetInteger(POSITION_MAGIC);
            string sym = PositionGetString(POSITION_SYMBOL);
            if(magic == MagicNumber && sym == _Symbol)
               return; // already an open position
           }
        }
     }
   // Check news filter
   if(NewsBlocked())
      return;
   // Determine direction of decisive candle
   double decOpen  = iOpen(_Symbol, DecisionTimeframe, 1);
   double decClose = iClose(_Symbol, DecisionTimeframe, 1);
   bool buyAllowed = true;
   bool sellAllowed = true;
   if(!GetHTFTrendPermissions(buyAllowed, sellAllowed))
      return;
   if(decClose > decOpen)
     {
      if(buyAllowed)
         EnterTrade(ORDER_TYPE_BUY);
      else
         Print("HTF EMA filter blocked BUY entry.");
     }
   else if(decClose < decOpen)
     {
      if(sellAllowed)
         EnterTrade(ORDER_TYPE_SELL);
      else
         Print("HTF EMA filter blocked SELL entry.");
     }
   else
     {
      Print("Decisive candle is doji. No trade opened.");
     }
  }
