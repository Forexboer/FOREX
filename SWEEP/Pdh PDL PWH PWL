//+------------------------------------------------------------------+
//|                                                UniversalBreakoutEA |
//|                                        PDH/PDL/PWH/PWL Breakout   |
//|   This Expert Advisor implements a universal breakout strategy    |
//|   based on previous day/week high and low levels. The strategy    |
//|   opens trades when price breaks above or below these reference   |
//|   levels on the current chart timeframe. It supports a broad set |
//|   of configurable parameters for multi‑timeframe operation, entry |
//|   rules, stop‑loss and take‑profit management, position sizing    |
//|   based on risk percentage or fixed lots, and risk‑limiting       |
//|   features such as maximum trades per day and cool‑down periods.  |
//|                                                                  |
//|   The implementation makes use of high‑timeframe price data       |
//|   (D1/W1) to calculate PDH/PDL (previous day high/low) and        |
//|   PWH/PWL (previous week high/low). Entries may occur on any     |
//|   timeframe.                                                     |
//|                                                                  |
//|   The lot size calculation for risk‑based position sizing uses    |
//|   the formula:                                                   |
//|      lots = risk_amount / (slDistance * tickValue),              |
//|   where tickValue is obtained from SymbolInfoDouble for the       |
//|   instrument. This method is described in the MQL5 forum         |
//|   discussions on risk calculations【844651351528829†L90-L111】.      |
//|   To convert pips to price for instruments with fractional pip    |
//|   pricing (e.g. 5‑digit forex quotes), the code adjusts by a      |
//|   factor of 10 (pips2dbl) according to guidance from the          |
//|   documentation【801445860127556†L134-L142】.                        |
//+------------------------------------------------------------------+
#property copyright "2025"
#property version   "1.00"
#property strict

#include <Trade/Trade.mqh>


//--- enumerations for various modes
enum EntryModeEnum { OnBreakTouch = 0, OnClose = 1 };
enum LevelPriorityEnum { DailyFirst = 0, WeeklyFirst = 1, FirstTriggered = 2 };
enum SLModeEnum { SLATR = 0, SLFixed = 1 };
enum TPModeEnum { TPRR = 0, TPFixed = 1 };
enum PositionSizingEnum { PSFixedLots = 0, PSRiskPercent = 1 };
enum UseBalanceOrEquityEnum { UseBalance = 0, UseEquity = 1 };

//--- input parameters
input bool             UsePDH                      = true;      // Use previous day high
input bool             UsePDL                      = true;      // Use previous day low
input bool             UsePWH                      = true;      // Use previous week high
input bool             UsePWL                      = true;      // Use previous week low
input bool             PlotLevels                 = true;      // Plot reference levels on chart
input double           LevelBufferPips            = 1.0;       // Buffer above/below level (pips)
input bool             UseCandleClose             = false;     // Require candle close beyond level before trading
input bool             ResetDaily                 = true;      // Automatically reset daily
input bool             ResetWeekly                = true;      // Automatically reset weekly

input EntryModeEnum    EntryMode                  = OnBreakTouch;   // Entry when price touches or closes
input bool             OneTradePerLevelPerDay     = true;      // Only one trade per level per day
input LevelPriorityEnum PriorityWhenMultipleLevels= DailyFirst;// Priority resolution when multiple levels trigger
input int              CooldownMinutes            = 30;        // Cool‑down period between trades (minutes)
input string           TradingHours               = "07:00-22:00"; // Active trading hours (HH:MM-HH:MM)

input SLModeEnum       SLMode                     = SLATR;     // Stop‑loss mode: ATR or fixed pips
input int              ATR_Period                 = 14;        // ATR period for SL calculation
input double           ATR_Multiplier             = 1.8;       // ATR multiplier for SL
input double           FixedSL_Pips               = 20.0;      // Fixed stop‑loss in pips

input TPModeEnum       TPMode                     = TPRR;      // Take‑profit mode: RR or fixed pips
input double           RR                         = 1.5;       // Risk:Reward ratio when TPMode = RR
input double           FixedTP_Pips               = 30.0;      // Fixed take‑profit in pips

input PositionSizingEnum PositionSizingMode       = PSRiskPercent; // Lot sizing mode
input double           FixedLots                  = 0.10;      // Fixed lots when using fixed lot size
input double           RiskPercentPerTrade        = 1.0;       // % of balance/equity risked per trade
input UseBalanceOrEquityEnum RiskUseBalanceOrEquity= UseEquity; // Use balance or equity for risk calc
input bool             IncludeCommissionsInRisk   = false;     // Include commission in risk calculation
input double           MinLots                    = 0.01;      // Minimum allowed lots (broker)
input double           MaxLots                    = 1.0;       // Maximum allowed lots (broker)
input double           LotStep                    = 0.01;      // Lot step (broker)

// Removed generic max trades per day option. Use directional limits below.
// input int           MaxTradesPerDay            = 3;
input int              MaxBuyTradesPerDay         = 1;         // Maximum buy trades per day
input int              MaxSellTradesPerDay        = 1;         // Maximum sell trades per day
// Debugging option: when enabled, the EA will print informative messages about order placement
// decisions and reasons for rejection. This helps diagnose why pending orders are not placed.
input bool             DebugLogging               = false;      // Enable debug logging

//--- chart template selection
// Apply a template to the chart on initialization. If true, the EA loads
// "Mijn template zwart.tpl" (black template) from the terminal's template
// directory; if false, it loads "mijn template.tpl". Ensure these files
// are available in the \Templates folder of the terminal. The user can
// select which template to use via this parameter.
// Chart appearance customization
// Users can set these colors to customize the chart's background and candlestick colors.
input color            ChartBackgroundColor     = clrWhite;   // Chart background color
input color            ChartForegroundColor     = clrBlack;   // Axes and text color
input color            GridColor                = 0xDDDDDD;    // Grid line color
input color            CandleBullColor          = clrGreen;   // Color of bullish candles
input color            CandleBearColor          = clrRed;     // Color of bearish candles
input double           MaxDailyRiskPercent        = 3.0;       // Maximum risk per day (% of balance/equity)
input int              MaxOpenPositions           = 3;         // Maximum simultaneous positions

//--- Magic number for identifying orders placed by this EA
input int              MagicNumber                = 123456;    // Unique magic number for all orders of this EA


//--- global variables
CTrade trade;                                      // Trading object

double           g_PDH = 0.0;                      // Previous day high level
double           g_PDL = 0.0;                      // Previous day low level
double           g_PWH = 0.0;                      // Previous week high level
double           g_PWL = 0.0;                      // Previous week low level

// Flags indicating whether the daily and weekly levels have been successfully calculated. These
// are set to true when UpdateDailyLevels() or UpdateWeeklyLevels() retrieves valid data and false
// otherwise. Pending orders should only be placed when the corresponding flag is true.
bool             g_DailyLevelsValid = false;
bool             g_WeeklyLevelsValid = false;

datetime         g_LastDailyUpdate  = 0;           // Last daily level update timestamp
datetime         g_LastWeeklyUpdate = 0;           // Last weekly level update timestamp

bool             pdh_traded = false;               // Flags indicating if a trade has occurred at each level
bool             pdl_traded = false;
bool             pwh_traded = false;
bool             pwl_traded = false;

int              g_TradesToday = 0;                // Count of trades opened today
double           g_DailyRiskUsed = 0.0;            // Accumulated risk used today

// Separate counters for buy and sell trades per day (limit 1 each as requested)
int              g_BuyTradesToday = 0;
int              g_SellTradesToday = 0;

// Flags indicating whether daily and weekly pending stop orders are currently placed
bool             g_DailyStopOrdersPlaced = false;
bool             g_WeeklyStopOrdersPlaced = false;

// Flags indicating whether risk has been accounted for each level
bool             g_RiskAddedPDH = false;
bool             g_RiskAddedPDL = false;
bool             g_RiskAddedPWH = false;
bool             g_RiskAddedPWL = false;

// Flag indicating that weekly stop orders have been removed as a result of a trade
// occurring at one of the weekly levels (PWH or PWL). When true, the EA will not attempt
// to place new weekly pending orders until the next weekly reset (Monday). This avoids
// immediately re‑creating PWH/PWL stops after they have been triggered.
bool             g_WeeklyOrdersRemovedByTrade = false;

datetime         g_LastTradeTime = 0;              // Timestamp of last trade

int              g_ATRHandle = INVALID_HANDLE;     // Handle for ATR indicator
int              g_TZOffsetMinutes = 0;            // Offset for local timezone (unused, reserved)

//--- parsed trading hours variables
int g_StartHour   = 0;
int g_StartMinute = 0;
int g_EndHour     = 23;
int g_EndMinute   = 59;

//+------------------------------------------------------------------+
//| Convert a time string "HH:MM" to hours and minutes               |
//+------------------------------------------------------------------+
void ParseTimeString(const string timeStr, int &hour, int &minute)
  {
   string tmp[];
   int n=StringSplit(timeStr,':',tmp);
   if(n>=2)
     {
      hour   =(int)StringToInteger(tmp[0]);
      minute =(int)StringToInteger(tmp[1]);
     }
  }

//+------------------------------------------------------------------+
//| Parse TradingHours input (format "HH:MM-HH:MM")                  |
//+------------------------------------------------------------------+
void ParseTradingHours()
  {
   string parts[];
   int count=StringSplit(TradingHours,'-',parts);
   if(count>=2)
     {
      ParseTimeString(parts[0],g_StartHour,g_StartMinute);
      ParseTimeString(parts[1],g_EndHour,g_EndMinute);
     }
  }

//+------------------------------------------------------------------+
//| Copy a template file from the terminal's Files directory to the Templates folder |
//| fileName: name of the template file to copy. If the file exists in Files,   |
//| it is written to Profiles\Templates so that ChartApplyTemplate can locate it.|
//+------------------------------------------------------------------+
void CopyTemplateFromFiles(const string fileName)
  {
   // Attempt to open the file from the Files directory. The Files directory is
   // part of the terminal's data path (\MQL5\Files) and is accessible for reading.
   int srcHandle = FileOpen(fileName, FILE_READ|FILE_BIN);
   if(srcHandle == INVALID_HANDLE)
      return;
   // Determine file size and read contents into array
   int size = (int)FileSize(srcHandle);
   uchar data[];
   ArrayResize(data, size);
   FileReadArray(srcHandle, data, 0, size);
   FileClose(srcHandle);
   // Build destination path in Templates directory
   string destPath = TerminalInfoString(TERMINAL_DATA_PATH) + "\\MQL5\\Profiles\\Templates\\" + fileName;
   int destHandle = FileOpen(destPath, FILE_WRITE|FILE_BIN);
   if(destHandle == INVALID_HANDLE)
      return;
   FileWriteArray(destHandle, data, 0, size);
   FileClose(destHandle);
  }

//+------------------------------------------------------------------+
//| Apply chart style directly instead of loading a .tpl file        |
//| When useBlack is true, a dark theme is applied; otherwise a      |
//| light theme. This removes the need for external template files.  |
//+------------------------------------------------------------------+
void ApplyChartStyle()
  {
   // Apply user‑defined chart colors
   // Background and axis/scale text
   ChartSetInteger(0,CHART_COLOR_BACKGROUND,ChartBackgroundColor);
   ChartSetInteger(0,CHART_COLOR_FOREGROUND,ChartForegroundColor);
   // Grid lines
   ChartSetInteger(0,CHART_COLOR_GRID,GridColor);
   // Candle body colors
   ChartSetInteger(0,CHART_COLOR_CANDLE_BULL,CandleBullColor);
   ChartSetInteger(0,CHART_COLOR_CANDLE_BEAR,CandleBearColor);
   // Set candlestick outline and shadow colors to match the body colors.  According to the
   // official enumeration list for chart properties【281912428121353†L381-L390】, the
   // CHART_COLOR_CHART_UP property controls the color of the up bar, its shadows and the
   // edging of bullish candles, while CHART_COLOR_CHART_DOWN controls the same aspects
   // for bearish candles.  By assigning these to the bull/bear body colors, the
   // candlestick borders and wicks will have the same color as the candle body, as the
   // user requested.
   ChartSetInteger(0,CHART_COLOR_CHART_UP,CandleBullColor);
   ChartSetInteger(0,CHART_COLOR_CHART_DOWN,CandleBearColor);
   // Refresh the chart to apply changes
   ChartRedraw(0);
  }

//+------------------------------------------------------------------+
//| Determine if current time is within trading hours                |
//+------------------------------------------------------------------+
bool InTradingHours()
  {
   datetime now=TimeLocal();
   MqlDateTime tm;
   TimeToStruct(now,tm);
   int currentMinutes=tm.hour*60+tm.min;
   int startMinutes=g_StartHour*60+g_StartMinute;
   int endMinutes  =g_EndHour*60+g_EndMinute;
   return (currentMinutes>=startMinutes && currentMinutes<=endMinutes);
  }

//+------------------------------------------------------------------+
//| Convert pips to price distance. Adjust for fractional digits.    |
//| Reference: guidance on pips vs points【801445860127556†L134-L142】   |
//+------------------------------------------------------------------+
double PipsToPrice(const double pips)
  {
   // For 5 or 3 digit symbols, one pip equals 10 points
   if(_Digits==5 || _Digits==3)
      return pips * _Point * 10.0;
   else
      return pips * _Point;
  }

//+------------------------------------------------------------------+
//| Convert price distance to pips.                                   |
//+------------------------------------------------------------------+
double PriceToPips(const double priceDiff)
  {
   if(_Digits==5 || _Digits==3)
      return priceDiff / (_Point * 10.0);
   else
      return priceDiff / _Point;
  }

//+------------------------------------------------------------------+
//| Update daily levels using D1 timeframe                           |
//+------------------------------------------------------------------+
bool UpdateDailyLevels()
  {
   double high[],low[];
   // copy previous day's high and low (shift=1)
   int copiedHigh=CopyHigh(_Symbol,PERIOD_D1,1,1,high);
   int copiedLow =CopyLow(_Symbol,PERIOD_D1,1,1,low);
   if(copiedHigh>0 && copiedLow>0)
     {
      g_PDH = high[0];
      g_PDL = low[0];
      g_DailyLevelsValid = true;
      return true;
     }
   // Mark daily levels as invalid when historical data is missing
   g_DailyLevelsValid = false;
   return false;
  }

//+------------------------------------------------------------------+
//| Update weekly levels using W1 timeframe                          |
//+------------------------------------------------------------------+
bool UpdateWeeklyLevels()
  {
   double high[],low[];
   int copiedHigh=CopyHigh(_Symbol,PERIOD_W1,1,1,high);
   int copiedLow =CopyLow(_Symbol,PERIOD_W1,1,1,low);
   if(copiedHigh>0 && copiedLow>0)
     {
      g_PWH = high[0];
      g_PWL = low[0];
      g_WeeklyLevelsValid = true;
      return true;
     }
   // Mark weekly levels as invalid when historical data is missing
   g_WeeklyLevelsValid = false;
   return false;
  }

//+------------------------------------------------------------------+
//| Reset daily trade flags and counters (PDH/PDL)                  |
//+------------------------------------------------------------------+
void ResetDailyFlags()
  {
   // Reset daily breakout flags only (PDH/PDL)
   pdh_traded=false;
   pdl_traded=false;
   // Reset counters for trades and risk used
   g_TradesToday=0;
   g_DailyRiskUsed=0.0;
   // Reset per‑direction trade counters
   g_BuyTradesToday=0;
   g_SellTradesToday=0;
   // Reset risk added flags for daily levels
   g_RiskAddedPDH=false;
   g_RiskAddedPDL=false;
  }

//+------------------------------------------------------------------+
//| Reset weekly trade flags (PWH/PWL)                              |
//+------------------------------------------------------------------+
void ResetWeeklyFlags()
  {
   pwh_traded=false;
   pwl_traded=false;
   // Reset risk added flags for weekly levels
   g_RiskAddedPWH=false;
   g_RiskAddedPWL=false;
   // When a new week begins, allow weekly pending orders to be placed again
   g_WeeklyOrdersRemovedByTrade = false;
  }

//+------------------------------------------------------------------+
//| Check if new day has started (server time)                      |
//+------------------------------------------------------------------+
bool IsNewDay()
  {
   datetime now=TimeCurrent();
   MqlDateTime tmNow,tmLast;
   TimeToStruct(now,tmNow);
   TimeToStruct(g_LastDailyUpdate,tmLast);
   return (tmNow.day!=tmLast.day || tmNow.mon!=tmLast.mon || tmNow.year!=tmLast.year);
  }

//+------------------------------------------------------------------+
//| Check if new week has started (Monday)                          |
//+------------------------------------------------------------------+
bool IsNewWeek()
  {
   datetime now=TimeCurrent();
   MqlDateTime tmNow,tmLast;
   TimeToStruct(now,tmNow);
   TimeToStruct(g_LastWeeklyUpdate,tmLast);
   // If the weekday changed and current day is Monday (1) then new week
   return (tmNow.day_of_week==1 && tmLast.day_of_week!=1);
  }

//+------------------------------------------------------------------+
//| Compute ATR‑based stop loss distance in price                   |
//+------------------------------------------------------------------+
double ComputeATRDistance()
  {
   if(g_ATRHandle==INVALID_HANDLE)
      return PipsToPrice(FixedSL_Pips); // fallback
   double atrBuffer[];
   if(CopyBuffer(g_ATRHandle,0,0,1,atrBuffer)>0)
     {
      return atrBuffer[0] * ATR_Multiplier;
     }
   return PipsToPrice(FixedSL_Pips);
  }

//+------------------------------------------------------------------+
//| Compute stop loss price based on mode and direction              |
//+------------------------------------------------------------------+
double ComputeStopPrice(const bool isBuy, const double entryPrice)
  {
   double slDistance=0.0;
   if(SLMode==SLATR)
     slDistance = ComputeATRDistance();
   else
     slDistance = PipsToPrice(FixedSL_Pips);
   if(isBuy)
      return entryPrice - slDistance;
   else
      return entryPrice + slDistance;
  }

//+------------------------------------------------------------------+
//| Compute take profit price based on mode and direction            |
//+------------------------------------------------------------------+
double ComputeTakeProfit(const bool isBuy,const double entryPrice,const double slPrice)
  {
   if(TPMode==TPRR)
     {
      double slDist=fabs(entryPrice-slPrice);
      double tpDist=slDist * RR;
      if(isBuy)
         return entryPrice + tpDist;
      else
         return entryPrice - tpDist;
     }
   else
     {
      double tpDist=PipsToPrice(FixedTP_Pips);
      if(isBuy)
         return entryPrice + tpDist;
      else
         return entryPrice - tpDist;
     }
  }

//+------------------------------------------------------------------+
//| Calculate risk‑based lot size or use fixed lots                 |
//| slDistancePoints: distance between entry and stop in price      |
//| tickvalue: tick value per lot for symbol                        |
//+------------------------------------------------------------------+
double CalculateLots(const double slDistancePrice)
  {
   double volume=FixedLots;
   if(PositionSizingMode==PSFixedLots)
     {
      volume=FixedLots;
     }
   else
     {
      // Determine account equity or balance for risk calculations
      double account=0.0;
      if(RiskUseBalanceOrEquity==UseEquity)
         account = AccountInfoDouble(ACCOUNT_EQUITY);
      else
         account = AccountInfoDouble(ACCOUNT_BALANCE);
      // Maximum risk amount for this trade
      double risk=account * RiskPercentPerTrade / 100.0;
      // Optionally include commissions (approximation)
      if(IncludeCommissionsInRisk)
        {
         double comm=0.0;
         // In absence of accurate commission retrieval, approximate as tick value per lot * spread
         // Not implemented: can be extended by user
         risk = MathMax(0.0,risk - comm);
        }
      // Obtain tick value and tick size. Tick value represents the monetary value of one
      // price change equal to the symbol's smallest tick (SYMBOL_TRADE_TICK_SIZE). For
      // typical forex pairs, ticksize equals _Point. To compute the potential loss per lot
      // over a price move of slDistancePrice, calculate how many ticks that distance
      // contains and multiply by tickvalue.
      double tickvalue = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      double ticksize  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
      double lots=0.0;
      if(slDistancePrice>0.0 && tickvalue>0.0 && ticksize>0.0)
        {
         // Number of ticks between entry and stop
         double ticks = slDistancePrice / ticksize;
         // Monetary risk per lot if stop hits
         double moneyPerLot = ticks * tickvalue;
         if(moneyPerLot>0.0)
           {
            lots = risk / moneyPerLot;
            // Align to lot step
            lots = MathFloor(lots / LotStep) * LotStep;
            // Clip to min/max
            lots = MathMin(lots,MaxLots);
            lots = MathMax(lots,MinLots);
           }
        }
      volume=lots;
     }
   // Ensure not below min and not above max
   volume = MathMax(MinLots, MathMin(volume, MaxLots));
   return volume;
  }

//+------------------------------------------------------------------+
//| Remove all pending stop orders (buy and sell) for daily levels   |
//| These orders are identified by the MagicNumber, symbol and       |
//| comments "PDH" or "PDL".                                         |
//+------------------------------------------------------------------+
void RemoveDailyStopOrders()
  {
   int total_orders = OrdersTotal();
   for(int i = total_orders - 1; i >= 0; i--)
     {
      // Retrieve the order ticket by index
      ulong ticket = OrderGetTicket(i);
      if(ticket == 0)
         continue;
      // Select the order to access its properties
      if(!OrderSelect(ticket))
         continue;
      // Filter by symbol and magic number
      if(OrderGetString(ORDER_SYMBOL) == _Symbol && OrderGetInteger(ORDER_MAGIC) == MagicNumber)
        {
         ENUM_ORDER_TYPE type = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
         if(type == ORDER_TYPE_BUY_STOP || type == ORDER_TYPE_SELL_STOP)
           {
            string com = OrderGetString(ORDER_COMMENT);
            // Prefix matching: remove PDH/PDL variants
            bool isPDH = (StringLen(com) >= 3 && StringSubstr(com, 0, 3) == "PDH");
            bool isPDL = (StringLen(com) >= 3 && StringSubstr(com, 0, 3) == "PDL");
            if(isPDH || isPDL)
              {
               if(DebugLogging) Print("Removing daily pending order ", ticket, ", comment=", com);
               trade.OrderDelete(ticket);
              }
           }
        }
     }
   g_DailyStopOrdersPlaced = false;
  }

//+------------------------------------------------------------------+
//| Remove all pending stop orders for weekly levels                 |
//| These orders have comments "PWH" or "PWL"                      |
//+------------------------------------------------------------------+
void RemoveWeeklyStopOrders()
  {
   int total_orders=OrdersTotal();
   // Iterate through the orders in reverse order so that deletion does not affect indexing
   for(int i=total_orders-1; i>=0; i--)
     {
      // Retrieve the order ticket by index. In MQL5 `OrderSelect` does not allow selection
      // by position, so we first obtain the ticket using OrderGetTicket().
      ulong ticket = OrderGetTicket(i);
      if(ticket==0)
         continue;
      // Select the order by its ticket to access its properties
      if(!OrderSelect(ticket))
         continue;
      // Filter orders by current symbol and EA magic number
      if(OrderGetString(ORDER_SYMBOL)==_Symbol && OrderGetInteger(ORDER_MAGIC)==MagicNumber)
        {
         ENUM_ORDER_TYPE type = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
         if(type == ORDER_TYPE_BUY_STOP || type == ORDER_TYPE_SELL_STOP)
           {
            string com = OrderGetString(ORDER_COMMENT);
            // Prefix matching: remove PWH/PWL variants
            bool isPWH = (StringLen(com) >= 3 && StringSubstr(com, 0, 3) == "PWH");
            bool isPWL = (StringLen(com) >= 3 && StringSubstr(com, 0, 3) == "PWL");
            if(isPWH || isPWL)
              {
               if(DebugLogging) Print("Removing weekly pending order ", ticket, ", comment=", com);
               trade.OrderDelete(ticket);
              }
           }
        }
     }
   // Flag that weekly stop orders are no longer active
   g_WeeklyStopOrdersPlaced=false;
  }

//+------------------------------------------------------------------+
//| Remove pending stop orders whose comment begins with a specific  |
//| prefix. Used when one side of the breakout is triggered, but     |
//| the opposite pending order should remain. All orders whose       |
//| comment starts with the provided prefix (e.g., "PDH", "PDL",     |
//| "PWH", "PWL") will be removed. This accommodates comment        |
//| variants such as "PDH#1", "PDL-buy", etc. The flags             |
//| g_DailyStopOrdersPlaced and g_WeeklyStopOrdersPlaced are not     |
//| altered by this function.                                        |
//+------------------------------------------------------------------+
void RemoveStopOrdersByComment(const string prefix)
  {
   int total_orders = OrdersTotal();
   for(int i = total_orders - 1; i >= 0; i--)
     {
      ulong ticket = OrderGetTicket(i);
      if(ticket==0)
         continue;
      if(!OrderSelect(ticket))
         continue;
      // Only consider orders from this symbol and this EA (magic number)
      if(OrderGetString(ORDER_SYMBOL)==_Symbol && OrderGetInteger(ORDER_MAGIC)==MagicNumber)
        {
         ENUM_ORDER_TYPE type=(ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
         if(type==ORDER_TYPE_BUY_STOP || type==ORDER_TYPE_SELL_STOP)
           {
            string com = OrderGetString(ORDER_COMMENT);
            // Remove any order whose comment begins with the specified prefix
            if(StringLen(com) >= StringLen(prefix) && StringSubstr(com, 0, StringLen(prefix)) == prefix)
              {
               if(DebugLogging) Print("Removing pending order ", ticket, ", comment=", com, " (prefix=", prefix, ")");
               trade.OrderDelete(ticket);
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| Place pending stop orders for daily breakout levels              |
//| Places a Buy Stop above PDH and a Sell Stop below PDL with      |
//| appropriate SL/TP, volume and comments. Orders are only placed  |
//| if their respective level has not already triggered a trade.     |
//+------------------------------------------------------------------+
void PlaceDailyStopOrders()
  {
   // If daily stop orders have already been placed, do not place again
   if(g_DailyStopOrdersPlaced)
      return;
   // Ensure the trade object uses the configured magic number before placing pending orders.
   trade.SetExpertMagicNumber(MagicNumber);
   // Track whether any order has been placed so we only mark the flag when appropriate
   bool orderPlaced = false;
   // Determine buffer price from pips
   double bufferPrice=PipsToPrice(LevelBufferPips);
   // Retrieve stop level requirements (minimum distance in points) for this symbol
   int stopsLevelPoints = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
   double minStopDistance = stopsLevelPoints * _Point;
   // Place buy stop at PDH+buffer
   if(UsePDH && !pdh_traded)
     {
      double entryPrice=g_PDH + bufferPrice;
      // Enforce minimum distance from current ask price
      double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      if((entryPrice - ask) < minStopDistance)
         entryPrice = ask + minStopDistance;
      // Compute stop loss and take profit for buy
      double slPrice=ComputeStopPrice(true,entryPrice);
      double tpPrice=ComputeTakeProfit(true,entryPrice,slPrice);
      double slDist=fabs(entryPrice-slPrice);
      double tickvalue=SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      // Determine lots using risk calculations
      double lots=(PositionSizingMode==PSFixedLots ? FixedLots : CalculateLots(slDist));
      // Use CheckVolume to ensure the requested volume is allowable (margin, min/max lot)
      double corrected = trade.CheckVolume(_Symbol, lots, entryPrice, ORDER_TYPE_BUY_STOP);
      if(corrected>0)
         lots = corrected;
      // Estimate the monetary risk of this order: number of ticks from entry to stop multiplied
      // by tick value and lots
      double riskAmount=((slDist / SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE)) * tickvalue) * lots;
      // Ensure risk limits allow this order
      if(DebugLogging)
         Print("Attempting BuyStop (PDH): entry=", entryPrice, ", SL=", slPrice, ", TP=", tpPrice, ", volume=", lots);
      if(CanEnterTrade(true,slDist,riskAmount))
        {
         // place buy stop order; comment indicates PDH
         string reason="PDH";
         if(trade.BuyStop(lots,entryPrice,_Symbol,slPrice,tpPrice,ORDER_TIME_GTC,0,reason))
            orderPlaced = true;
         else if(DebugLogging)
            Print("BuyStop (PDH) failed to send");
        }
      else if(DebugLogging)
         Print("BuyStop (PDH) skipped due to CanEnterTrade returning false");
     }
   // Place sell stop at PDL-buffer
   if(UsePDL && !pdl_traded)
     {
      double entryPrice=g_PDL - bufferPrice;
      // Enforce minimum distance from current bid price for sell stop
      double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
      if((bid - entryPrice) < minStopDistance)
         entryPrice = bid - minStopDistance;
      double slPrice=ComputeStopPrice(false,entryPrice);
      double tpPrice=ComputeTakeProfit(false,entryPrice,slPrice);
      double slDist=fabs(entryPrice-slPrice);
      double tickvalue=SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      double lots=(PositionSizingMode==PSFixedLots ? FixedLots : CalculateLots(slDist));
      // Ensure volume is within broker limits and free margin. Use CheckVolume.
      double corrected = trade.CheckVolume(_Symbol, lots, entryPrice, ORDER_TYPE_SELL_STOP);
      if(corrected>0)
         lots = corrected;
      double riskAmount=((slDist / SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE)) * tickvalue) * lots;
      if(DebugLogging)
         Print("Attempting SellStop (PDL): entry=", entryPrice, ", SL=", slPrice, ", TP=", tpPrice, ", volume=", lots);
      if(CanEnterTrade(false,slDist,riskAmount))
        {
         string reason="PDL";
         if(trade.SellStop(lots,entryPrice,_Symbol,slPrice,tpPrice,ORDER_TIME_GTC,0,reason))
            orderPlaced = true;
         else if(DebugLogging)
            Print("SellStop (PDL) failed to send");
        }
      else if(DebugLogging)
         Print("SellStop (PDL) skipped due to CanEnterTrade returning false");
     }
   // Only set the flag if at least one pending order was successfully placed. This prevents
   // disabling subsequent attempts if risk or time conditions prevented placement.
   if(orderPlaced)
      g_DailyStopOrdersPlaced = true;
  }

//+------------------------------------------------------------------+
//| Place pending stop orders for weekly breakout levels            |
//| Similar to daily orders but for PWH/PWL levels                 |
//+------------------------------------------------------------------+
void PlaceWeeklyStopOrders()
  {
   // If weekly stop orders have already been placed, skip placing again
   if(g_WeeklyStopOrdersPlaced)
      return;
   // Ensure the trade object uses the configured magic number before placing pending orders
   trade.SetExpertMagicNumber(MagicNumber);
   bool orderPlaced = false;
   // Retrieve the broker's minimum stop distance (in points) and convert to price distance
   int stopsLevelPoints = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
   double minStopDistance = stopsLevelPoints * _Point;
   double bufferPrice=PipsToPrice(LevelBufferPips);
   // Place buy stop at PWH + buffer
   if(UsePWH && !pwh_traded)
     {
      double entryPrice = g_PWH + bufferPrice;
      // Ensure buy stop is sufficiently above the current ask price
      double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      if((entryPrice - ask) < minStopDistance)
         entryPrice = ask + minStopDistance;
      double slPrice    = ComputeStopPrice(true, entryPrice);
      double tpPrice    = ComputeTakeProfit(true, entryPrice, slPrice);
      double slDist     = fabs(entryPrice - slPrice);
      double tickvalue  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      double lots       = (PositionSizingMode==PSFixedLots ? FixedLots : CalculateLots(slDist));
      // Adjust lots using CheckVolume to ensure margin requirements are met for pending orders
      double corrected = trade.CheckVolume(_Symbol, lots, entryPrice, ORDER_TYPE_BUY_STOP);
      if(corrected>0)
         lots = corrected;
      double riskAmount = ((slDist / SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE)) * tickvalue) * lots;
      if(DebugLogging)
         Print("Attempting BuyStop (PWH): entry=", entryPrice, ", SL=", slPrice, ", TP=", tpPrice, ", volume=", lots);
      if(CanEnterTrade(true,slDist,riskAmount))
        {
         string reason = "PWH";
         if(trade.BuyStop(lots, entryPrice, _Symbol, slPrice, tpPrice, ORDER_TIME_GTC, 0, reason))
            orderPlaced = true;
         else if(DebugLogging)
            Print("BuyStop (PWH) failed to send");
        }
      else if(DebugLogging)
         Print("BuyStop (PWH) skipped due to CanEnterTrade returning false");
     }
   // Place sell stop at PWL - buffer
   if(UsePWL && !pwl_traded)
     {
      double entryPrice = g_PWL - bufferPrice;
      // Ensure sell stop is sufficiently below the current bid price
      double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
      if((bid - entryPrice) < minStopDistance)
         entryPrice = bid - minStopDistance;
      double slPrice    = ComputeStopPrice(false, entryPrice);
      double tpPrice    = ComputeTakeProfit(false, entryPrice, slPrice);
      double slDist     = fabs(entryPrice - slPrice);
      double tickvalue  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      double lots       = (PositionSizingMode==PSFixedLots ? FixedLots : CalculateLots(slDist));
      // Adjust lots using CheckVolume for sell stop
      double corrected = trade.CheckVolume(_Symbol, lots, entryPrice, ORDER_TYPE_SELL_STOP);
      if(corrected>0)
         lots = corrected;
      double riskAmount = ((slDist / SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE)) * tickvalue) * lots;
      if(DebugLogging)
         Print("Attempting SellStop (PWL): entry=", entryPrice, ", SL=", slPrice, ", TP=", tpPrice, ", volume=", lots);
      if(CanEnterTrade(false,slDist,riskAmount))
        {
         string reason = "PWL";
         if(trade.SellStop(lots, entryPrice, _Symbol, slPrice, tpPrice, ORDER_TIME_GTC, 0, reason))
            orderPlaced = true;
         else if(DebugLogging)
            Print("SellStop (PWL) failed to send");
        }
      else if(DebugLogging)
         Print("SellStop (PWL) skipped due to CanEnterTrade returning false");
     }
   // Mark that weekly orders have been placed only if at least one was successfully submitted
   if(orderPlaced)
      g_WeeklyStopOrdersPlaced = true;
  }

//+------------------------------------------------------------------+
//| Place market orders for daily breakout levels                    |
//| Opens a Buy or Sell market order when price breaks above PDH or  |
//| below PDL, respectively. Does not use pending stop orders.      |
//+------------------------------------------------------------------+
void PlaceDailyMarketOrders()
  {
   // Only one daily trade per direction; exit if already traded
   if(pdh_traded || pdl_traded)
      return;
   double buffer = PipsToPrice(LevelBufferPips);
   // Attempt buy breakout above PDH
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   if(UsePDH && ask > g_PDH + buffer)
     {
      double sl = ComputeStopPrice(true, ask);
      double tp = ComputeTakeProfit(true, ask, sl);
      // Determine position size
      double slDist = MathAbs(ask - sl);
      double lots = (PositionSizingMode==PSFixedLots ? FixedLots : CalculateLots(slDist));
      double intendedRisk = 0.0;
      double ticksize  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
      double tickvalue = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      if(ticksize>0.0)
         intendedRisk = (slDist / ticksize) * tickvalue * lots;
      if(CanEnterTrade(true, slDist, intendedRisk))
         PlaceTrade(true, ask, sl, tp, lots, "PDH");
     }
   // Attempt sell breakout below PDL
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   if(UsePDL && bid < g_PDL - buffer)
     {
      double sl = ComputeStopPrice(false, bid);
      double tp = ComputeTakeProfit(false, bid, sl);
      double slDist = MathAbs(bid - sl);
      double lots = (PositionSizingMode==PSFixedLots ? FixedLots : CalculateLots(slDist));
      double intendedRisk = 0.0;
      double ticksize  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
      double tickvalue = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      if(ticksize>0.0)
         intendedRisk = (slDist / ticksize) * tickvalue * lots;
      if(CanEnterTrade(false, slDist, intendedRisk))
         PlaceTrade(false, bid, sl, tp, lots, "PDL");
     }
  }

//+------------------------------------------------------------------+
//| Place market orders for weekly breakout levels                   |
//| Opens a Buy or Sell market order when price breaks above PWH or  |
//| below PWL.                                                      |
//+------------------------------------------------------------------+
void PlaceWeeklyMarketOrders()
  {
   // Only one weekly trade per direction; exit if already traded
   if(pwh_traded || pwl_traded)
      return;
   double buffer = PipsToPrice(LevelBufferPips);
   // Buy breakout above PWH
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   if(UsePWH && ask > g_PWH + buffer)
     {
      double sl = ComputeStopPrice(true, ask);
      double tp = ComputeTakeProfit(true, ask, sl);
      double slDist = MathAbs(ask - sl);
      double lots = (PositionSizingMode==PSFixedLots ? FixedLots : CalculateLots(slDist));
      double intendedRisk = 0.0;
      double ticksize  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
      double tickvalue = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      if(ticksize>0.0)
         intendedRisk = (slDist / ticksize) * tickvalue * lots;
      if(CanEnterTrade(true, slDist, intendedRisk))
         PlaceTrade(true, ask, sl, tp, lots, "PWH");
     }
   // Sell breakout below PWL
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   if(UsePWL && bid < g_PWL - buffer)
     {
      double sl = ComputeStopPrice(false, bid);
      double tp = ComputeTakeProfit(false, bid, sl);
      double slDist = MathAbs(bid - sl);
      double lots = (PositionSizingMode==PSFixedLots ? FixedLots : CalculateLots(slDist));
      double intendedRisk = 0.0;
      double ticksize  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
      double tickvalue = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      if(ticksize>0.0)
         intendedRisk = (slDist / ticksize) * tickvalue * lots;
      if(CanEnterTrade(false, slDist, intendedRisk))
         PlaceTrade(false, bid, sl, tp, lots, "PWL");
     }
  }

//+------------------------------------------------------------------+
//| Manage open positions and update flags/risk                     |
//| Checks open positions belonging to this EA (by magic and symbol)|
//| If a position corresponds to a particular level (based on the  |
//| comment), set the trade flag and remove pending orders for the   |
//| opposite levels. Accumulate risk used.                          |
//+------------------------------------------------------------------+
void ManageOpenPositions()
  {
   int total=PositionsTotal();
   // Iterate over all open positions and select each by its ticket before
   // accessing its properties.  PositionGetString/POSITION_* functions operate
   // on the selected position, so we must select by ticket first.
   for(int i=0; i<total; i++)
     {
      ulong ticket = PositionGetTicket(i);
      if(ticket==0)
         continue;
      // Select the position by its ticket.  If selection fails skip it.
      if(!PositionSelectByTicket(ticket))
         continue;
      // Filter by symbol; use PositionGetString on the selected position
      string sym = PositionGetString(POSITION_SYMBOL);
      if(sym!=_Symbol)
         continue;
      long pos_magic = PositionGetInteger(POSITION_MAGIC);
      if(pos_magic!=MagicNumber)
         continue;
      // Identify by comment
      string cmt = PositionGetString(POSITION_COMMENT);
      if(DebugLogging)
        {
         Print("Managing position: ticket ", PositionGetInteger(POSITION_TICKET), ", comment=", cmt);
        }
      // Determine if this is a new trade for the day/week
      // Update flags and remove corresponding pending orders
      if(cmt=="PDH")
        {
         bool newlySet = !pdh_traded;
         pdh_traded = true;
         if(PlotLevels)
            ObjectDelete(0, "PDH");
         if(newlySet)
           {
            g_LastTradeTime = TimeCurrent();
            ENUM_POSITION_TYPE ptype = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(ptype == POSITION_TYPE_BUY)
               g_BuyTradesToday++;
            else
               g_SellTradesToday++;
           }
        }
      else if(cmt=="PDL")
        {
         bool newlySet = !pdl_traded;
         pdl_traded = true;
         if(PlotLevels)
            ObjectDelete(0, "PDL");
         if(newlySet)
           {
            g_LastTradeTime = TimeCurrent();
            ENUM_POSITION_TYPE ptype = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(ptype == POSITION_TYPE_BUY)
               g_BuyTradesToday++;
            else
               g_SellTradesToday++;
           }
        }
      else if(cmt=="PWH")
        {
         bool newlySet = !pwh_traded;
         pwh_traded = true;
         pdh_traded = true;
         if(PlotLevels)
            ObjectDelete(0, "PWH");
         if(PlotLevels)
            ObjectDelete(0, "PDH");
         if(newlySet)
           {
            g_LastTradeTime = TimeCurrent();
            ENUM_POSITION_TYPE ptype = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(ptype == POSITION_TYPE_BUY)
               g_BuyTradesToday++;
            else
               g_SellTradesToday++;
           }
        }
      else if(cmt=="PWL")
        {
         bool newlySet = !pwl_traded;
         pwl_traded = true;
         pdl_traded = true;
         if(PlotLevels)
            ObjectDelete(0, "PWL");
         if(PlotLevels)
            ObjectDelete(0, "PDL");
         if(newlySet)
           {
            g_LastTradeTime = TimeCurrent();
            ENUM_POSITION_TYPE ptype = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(ptype == POSITION_TYPE_BUY)
               g_BuyTradesToday++;
            else
               g_SellTradesToday++;
           }
        }
      // Update risk used only once per comment using risk flags
      double open   = PositionGetDouble(POSITION_PRICE_OPEN);
      double sl     = PositionGetDouble(POSITION_SL);
      double vol    = PositionGetDouble(POSITION_VOLUME);
      double tickvalue = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      double ticksize  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
      // Calculate risk used for this position in monetary terms: distance in ticks × tickvalue × volume
      double risk = 0.0;
      if(ticksize>0.0)
        {
         double ticks = fabs(open - sl) / ticksize;
         risk = ticks * tickvalue * vol;
        }
      if(cmt=="PDH" && pdh_traded && !g_RiskAddedPDH)
        {
         g_DailyRiskUsed += risk;
         g_RiskAddedPDH=true;
        }
      else if(cmt=="PDL" && pdl_traded && !g_RiskAddedPDL)
        {
         g_DailyRiskUsed += risk;
         g_RiskAddedPDL=true;
        }
      else if(cmt=="PWH" && pwh_traded && !g_RiskAddedPWH)
        {
         g_DailyRiskUsed += risk;
         g_RiskAddedPWH=true;
        }
      else if(cmt=="PWL" && pwl_traded && !g_RiskAddedPWL)
        {
         g_DailyRiskUsed += risk;
         g_RiskAddedPWL=true;
        }
     }
  }
//+------------------------------------------------------------------+
//| Check risk limits and other trading restrictions                |
//+------------------------------------------------------------------+
// Check risk limits and other trading restrictions, including per‑direction limits
bool CanEnterTrade(const bool isBuy,const double slDistancePrice, const double intendedRisk)
  {
   datetime now=TimeCurrent();
   string direction = isBuy ? "Buy" : "Sell";
   // Check trading hours
   if(!InTradingHours())
     {
      if(DebugLogging) Print(direction, " trade blocked: outside trading hours");
      return false;
     }
   // Check cool‑down
   if((g_LastTradeTime!=0) && ((now - g_LastTradeTime) < CooldownMinutes*60))
     {
      if(DebugLogging) Print(direction, " trade blocked: cooldown period active");
      return false;
     }
   // Check per direction trade limits (configurable number of buy and sell trades per day)
   if(isBuy && g_BuyTradesToday >= MaxBuyTradesPerDay)
     {
      if(DebugLogging) Print(direction, " trade blocked: max buy trades per day reached (", g_BuyTradesToday, "/", MaxBuyTradesPerDay, ")");
      return false;
     }
   if(!isBuy && g_SellTradesToday >= MaxSellTradesPerDay)
     {
      if(DebugLogging) Print(direction, " trade blocked: max sell trades per day reached (", g_SellTradesToday, "/", MaxSellTradesPerDay, ")");
      return false;
     }
   // Check max open positions for this symbol
   if(MaxOpenPositions>0)
     {
      int total=0;
      int positions_total=PositionsTotal();
      for(int i=0; i<positions_total; i++)
        {
         string symbol=PositionGetSymbol(i);
         if(symbol==_Symbol)
            total++;
        }
      if(total >= MaxOpenPositions)
        {
         if(DebugLogging) Print(direction, " trade blocked: max open positions reached (", total, "/", MaxOpenPositions, ")");
         return false;
        }
     }
   // Check daily risk limit
   double account=0.0;
   if(RiskUseBalanceOrEquity==UseEquity)
      account = AccountInfoDouble(ACCOUNT_EQUITY);
   else
      account = AccountInfoDouble(ACCOUNT_BALANCE);
   double maxDailyRisk=account * MaxDailyRiskPercent / 100.0;
   if(g_DailyRiskUsed + intendedRisk > maxDailyRisk)
     {
      if(DebugLogging) Print(direction, " trade blocked: risk limit exceeded (", g_DailyRiskUsed, "+", intendedRisk, ">", maxDailyRisk, ")");
      return false;
     }
   return true;
  }

//+------------------------------------------------------------------+
//| Execute breakout trade helper                                   |
//+------------------------------------------------------------------+
bool ExecuteBreakoutTrade(const bool isBuy, const string reason)
  {
   double price = isBuy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                        : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double sl    = ComputeStopPrice(isBuy, price);
   double tp    = ComputeTakeProfit(isBuy, price, sl);
   double slDist = MathAbs(price - sl);
   double lots   = (PositionSizingMode==PSFixedLots ? FixedLots : CalculateLots(slDist));
   double intendedRisk = 0.0;
   double ticksize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickvalue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   if(ticksize>0.0 && tickvalue>0.0)
      intendedRisk = (slDist / ticksize) * tickvalue * lots;
   if(!CanEnterTrade(isBuy, slDist, intendedRisk))
      return false;
   return PlaceTrade(isBuy, price, sl, tp, lots, reason);
  }

//+------------------------------------------------------------------+
//| Place a market order                                            |
//+------------------------------------------------------------------+
bool PlaceTrade(const bool isBuy, const double price, const double stopPrice, const double takeProfitPrice, const double volume, const string reason)
  {
   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);
   ZeroMemory(result);
   request.action   = TRADE_ACTION_DEAL;
   request.symbol   = _Symbol;
   request.volume   = volume;
   request.price    = isBuy ? SymbolInfoDouble(_Symbol,SYMBOL_ASK) : SymbolInfoDouble(_Symbol,SYMBOL_BID);
   request.sl       = stopPrice;
   request.tp       = takeProfitPrice;
   request.deviation= 10; // allowable slippage (points)
   request.type     = isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   // Determine the broker's supported filling mode and apply it. If unavailable, fall back to RETURN.
   int fillingMode = (int)SymbolInfoInteger(_Symbol, SYMBOL_FILLING_MODE);
   if(fillingMode <= 0)
      fillingMode = ORDER_FILLING_RETURN;
   request.type_filling = (ENUM_ORDER_TYPE_FILLING)fillingMode;
   request.type_time    = ORDER_TIME_GTC;
   request.comment      = reason;
   // Verify the requested volume is within broker constraints
   if(!trade.CheckVolume(request.symbol, request.volume, request.price, request.type))
      return false;
   bool success=OrderSend(request,result);
   if(success && result.retcode==10009/*deal placed*/)
     {
      g_LastTradeTime=TimeCurrent();
      g_TradesToday++;
      // Increment per‑direction counters
      if(isBuy)
         g_BuyTradesToday++;
      else
         g_SellTradesToday++;
      // Compute risk used based on distance in price. Convert the price difference to number of ticks
      // and multiply by tick value and volume to get monetary risk.
      double ticksize  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
      double tickvalue = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
      if(ticksize>0.0 && tickvalue>0.0)
        {
         double ticks = fabs(price - stopPrice) / ticksize;
         double riskAmount = ticks * tickvalue * volume;
         g_DailyRiskUsed += riskAmount;
        }
      return true;
     }
   return false;
  }

//+------------------------------------------------------------------+
//| Plot or update level objects on chart                           |
//+------------------------------------------------------------------+
void UpdatePlot(const string name,const double level,const color clr)
  {
   if(!PlotLevels)
      return;
   // Create or update horizontal line
   if(ObjectFind(0,name)<0)
     {
      ObjectCreate(0,name,OBJ_HLINE,0,0,level);
      ObjectSetInteger(0,name,OBJPROP_COLOR,clr);
      ObjectSetInteger(0,name,OBJPROP_STYLE,STYLE_DOT);
      ObjectSetInteger(0,name,OBJPROP_WIDTH,1);
      ObjectSetInteger(0,name,OBJPROP_BACK,true);
     }
   else
     {
      ObjectMove(0,name,0,0,level);
     }
  }

//+------------------------------------------------------------------+
//| Entry check for level breakout                                  |
//+------------------------------------------------------------------+
bool CheckBreakout(const double level,const bool isUpper,const double bufferPrice,const bool checkClose)
  {
   // Determine if price crosses the level plus buffer (upper) or minus buffer (lower)
   if(checkClose)
     {
      // Use last closed bar
      // obtain the close of the previous bar via iClose since EAs cannot access Close[] directly
      double prevClose=iClose(_Symbol,PERIOD_CURRENT,1);
      if(isUpper)
         return (prevClose > (level + bufferPrice));
      else
         return (prevClose < (level - bufferPrice));
     }
   else
     {
      // Use current Ask/Bid for real‑time touch
      double price = isUpper ? SymbolInfoDouble(_Symbol,SYMBOL_ASK) : SymbolInfoDouble(_Symbol,SYMBOL_BID);
      if(isUpper)
         return (price > (level + bufferPrice));
      else
         return (price < (level - bufferPrice));
     }
  }

//+------------------------------------------------------------------+
//| Determine which level triggered when multiple triggers occur    |
//+------------------------------------------------------------------+
int ResolveLevelPriority(const bool dailyTriggered,const bool weeklyTriggered)
  {
   switch(PriorityWhenMultipleLevels)
     {
      case DailyFirst:
         if(dailyTriggered)
            return 0; // daily wins
         if(weeklyTriggered)
            return 1;
         break;
      case WeeklyFirst:
         if(weeklyTriggered)
            return 1;
         if(dailyTriggered)
            return 0;
         break;
      case FirstTriggered:
        {
         // Could be based on whichever is closer; approximate by distance from current mid price
         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
         double midPrice = (ask+bid)/2.0;
         // compute distances of current price to levels (use averages of high/low for convenience)
         double dailyDist = 0.0;
         double weeklyDist = 0.0;
         if(dailyTriggered)
            dailyDist = MathAbs(midPrice - ((g_PDH + g_PDL) / 2.0));
         if(weeklyTriggered)
            weeklyDist = MathAbs(midPrice - ((g_PWH + g_PWL) / 2.0));
         if(dailyTriggered && weeklyTriggered)
           {
            return (dailyDist <= weeklyDist) ? 0 : 1;
           }
         else if(dailyTriggered)
           return 0;
         else if(weeklyTriggered)
           return 1;
         break;
        }
     }
   return -1;
  }

//+------------------------------------------------------------------+
//| Expert initialization                                            |
//+------------------------------------------------------------------+
int OnInit()
  {
   // Parse trading hours
   ParseTradingHours();
   // Create ATR handle if required
   if(SLMode==SLATR)
     {
      g_ATRHandle = iATR(_Symbol,PERIOD_CURRENT,ATR_Period);
      if(g_ATRHandle==INVALID_HANDLE)
         Print("Failed to create ATR handle");
     }
   // Update levels immediately
   UpdateDailyLevels();
   g_LastDailyUpdate = TimeCurrent();
   UpdateWeeklyLevels();
   g_LastWeeklyUpdate = TimeCurrent();
   // Ensure weekly orders removed flag is cleared on initialization
   g_WeeklyOrdersRemovedByTrade = false;
   // Apply chart appearance based on user-defined colors
   ApplyChartStyle();
   
   // Set the expert magic number for all orders
   trade.SetExpertMagicNumber(MagicNumber);
   
   // Plot the reference levels
   UpdatePlot("PDH",g_PDH,clrGreen);
   UpdatePlot("PDL",g_PDL,clrOrangeRed);
   UpdatePlot("PWH",g_PWH,clrDodgerBlue);
   UpdatePlot("PWL",g_PWL,clrPurple);

   // Evaluate local time context; trades are opened from OnTick logic
   MqlDateTime tm;
   TimeToStruct(TimeLocal(),tm);
   // Trading entries are managed in OnTick using real-time conditions
   return INIT_SUCCEEDED;
  }

//+------------------------------------------------------------------+
//| Expert deinitialization                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   // Release ATR handle
   if(g_ATRHandle!=INVALID_HANDLE)
     {
      IndicatorRelease(g_ATRHandle);
      g_ATRHandle=INVALID_HANDLE;
     }
   // Remove objects if plotted
   if(PlotLevels)
     {
      ObjectDelete(0,"PDH");
      ObjectDelete(0,"PDL");
      ObjectDelete(0,"PWH");
      ObjectDelete(0,"PWL");
     }
   // Remove any remaining pending orders created by this EA
   RemoveDailyStopOrders();
   RemoveWeeklyStopOrders();
  }

//+------------------------------------------------------------------+
//| Per‑tick event handler                                          |
//+------------------------------------------------------------------+
void OnTick()
  {
   datetime now=TimeCurrent();
   static datetime last_day = 0;
   static int      last_week = -1;
   // Convert the current local time to a structured format for day/time checks
   MqlDateTime tm;
   TimeToStruct(TimeLocal(),tm);
   // Reset trade flags on calendar changes to avoid stale state
   if(last_day==0)
      last_day = now;
   if(ResetDaily && TimeDay(now) != TimeDay(last_day))
     {
      pdh_traded = false;
      pdl_traded = false;
      last_day   = now;
     }
   int week_now = TimeDayOfYear(now) / 7;
   if(last_week==-1)
      last_week = week_now;
   if(ResetWeekly && week_now != last_week)
     {
      pwh_traded = false;
      pwl_traded = false;
      last_week  = week_now;
     }
   // Check if a new day has started.  At the beginning of a new day we always clean up any
   // leftover pending orders from the previous session and optionally reset daily trade flags.
   // This cleanup occurs regardless of whether new daily high/low values can be retrieved.
   if(IsNewDay())
     {
      // No pending stop orders to remove when using market orders
      // Optionally reset daily trade flags and counters at start of a new day
      if(ResetDaily)
        {
         ResetDailyFlags();
        }
      // Attempt to update the daily high/low levels.  Even if this fails (due to missing
      // historical data), advance the last daily update timestamp to prevent repeated
      // executions of this block on subsequent ticks.  UpdateDailyLevels() will set
      // g_DailyLevelsValid accordingly.
      bool dailyUpdateOK = UpdateDailyLevels();
      g_LastDailyUpdate = now;
      // When valid daily levels are available, update the reference lines on the chart
      if(dailyUpdateOK && g_DailyLevelsValid)
        {
         UpdatePlot("PDH", g_PDH, clrGreen);
         UpdatePlot("PDL", g_PDL, clrOrangeRed);
        }
      else
        {
         // Remove old level lines if plotting is enabled and new levels could not be determined
         if(PlotLevels)
           {
            ObjectDelete(0, "PDH");
            ObjectDelete(0, "PDL");
           }
        }
      // Place new daily pending orders only when it is not weekend or Friday late, trading
      // hours are open and daily levels are valid.  This avoids using stale reference
      // prices when data is unavailable.
      bool isWeekend  = (tm.day_of_week==0 || tm.day_of_week==6);
         // Trading decisions handled later in the tick using market execution logic
     }
   // Check if a new week has started (Monday).  Similar to the daily logic above, we
   // always remove any leftover weekly pending stop orders when a new week begins.  This
   // prevents stale PWH/PWL orders from persisting into the next week when weekly price
   // data cannot be retrieved.  After cleanup, we attempt to update the weekly levels,
   // plot them if available, and place fresh weekly orders when trading conditions allow.
   if(IsNewWeek())
     {
      // No pending stop orders to remove when using market orders
      // Attempt to update weekly high/low data.  Even if this fails, we advance the
      // last weekly update timestamp to avoid repeated cleanup on subsequent ticks.  The
      // UpdateWeeklyLevels() call updates g_WeeklyLevelsValid accordingly.
      bool weeklyUpdateOK = UpdateWeeklyLevels();
      g_LastWeeklyUpdate = now;
      // Reset weekly flags and optionally daily flags at the beginning of a new week
      if(ResetWeekly)
        {
         ResetWeeklyFlags();
         // Also reset daily flags on Monday morning
         ResetDailyFlags();
        }
      // When valid weekly levels are available, update the reference lines on the chart
      if(weeklyUpdateOK && g_WeeklyLevelsValid)
        {
         UpdatePlot("PWH", g_PWH, clrDodgerBlue);
         UpdatePlot("PWL", g_PWL, clrPurple);
        }
      else
        {
         // Remove old weekly level lines if plotting is enabled and new levels could not be
         // obtained
         if(PlotLevels)
           {
            ObjectDelete(0, "PWH");
            ObjectDelete(0, "PWL");
           }
        }
      // Place new weekly pending orders only when it is not Sunday or Friday late, trading hours
      // are open and weekly levels are valid.  This avoids using outdated price levels.
         // Trading decisions handled later in the tick using market execution logic
     }
   // Manage open positions: update flags, remove opposite pending orders and accumulate risk
   ManageOpenPositions();

   // We no longer remove all pending stop orders after a breakout here.
   // ManageOpenPositions() now deletes only the triggered order, leaving the opposite order active.

   // If no daily stop orders are currently active and daily levels are valid, keep trying to
   // place them on subsequent ticks until successful. This handles cases where the first
   // attempt at 00:00 may fail due to the market being closed; a later tick will succeed when
   // the market opens.
   // Evaluate trading hours again on each tick
   bool canTrade = InTradingHours();
   // Determine current local day and time
   MqlDateTime cur;
   TimeToStruct(TimeLocal(), cur);
   bool wknd = (cur.day_of_week==0 || cur.day_of_week==6);
   bool friLate = (cur.day_of_week==5 && cur.hour>=23);
   // Process breakout logic with per-tick trade limiter
   bool tradePlaced = false;
   double buffer = PipsToPrice(LevelBufferPips);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double lastClose = 0.0;
   if(UseCandleClose)
     {
      if(Bars(_Symbol, _Period) > 1)
         lastClose = iClose(_Symbol, _Period, 1);
      else
         lastClose = iClose(_Symbol, _Period, 0);
     }

   if(!tradePlaced && canTrade && !wknd && !friLate)
     {
      bool weeklyBreakHigh = false;
      bool dailyBreakHigh  = false;
      if(UseCandleClose)
        {
         weeklyBreakHigh = (g_WeeklyLevelsValid && lastClose > g_PWH + buffer);
         dailyBreakHigh  = (g_DailyLevelsValid && lastClose > g_PDH + buffer);
        }
      else
        {
         weeklyBreakHigh = (g_WeeklyLevelsValid && ask > g_PWH + buffer);
         dailyBreakHigh  = (g_DailyLevelsValid && ask > g_PDH + buffer);
        }
      if(UsePWH && !pwh_traded && weeklyBreakHigh)
        {
         if(ExecuteBreakoutTrade(true, "PWH"))
           {
            pwh_traded = true;
            pdh_traded = true;
            tradePlaced = true;
           }
        }
      else if(!tradePlaced && UsePDH && !pdh_traded && dailyBreakHigh)
        {
         if(ExecuteBreakoutTrade(true, "PDH"))
           {
            pdh_traded = true;
            tradePlaced = true;
           }
        }
     }

   if(!tradePlaced && canTrade && !wknd && !friLate)
     {
      bool weeklyBreakLow = false;
      bool dailyBreakLow  = false;
      if(UseCandleClose)
        {
         weeklyBreakLow = (g_WeeklyLevelsValid && lastClose < g_PWL - buffer);
         dailyBreakLow  = (g_DailyLevelsValid && lastClose < g_PDL - buffer);
        }
      else
        {
         weeklyBreakLow = (g_WeeklyLevelsValid && bid < g_PWL - buffer);
         dailyBreakLow  = (g_DailyLevelsValid && bid < g_PDL - buffer);
        }
      if(UsePWL && !pwl_traded && weeklyBreakLow)
        {
         if(ExecuteBreakoutTrade(false, "PWL"))
           {
            pwl_traded = true;
            pdl_traded = true;
            tradePlaced = true;
           }
        }
      else if(!tradePlaced && UsePDL && !pdl_traded && dailyBreakLow)
        {
         if(ExecuteBreakoutTrade(false, "PDL"))
           {
            pdl_traded = true;
            tradePlaced = true;
           }
        }
     }

   // On Friday at 23:00 or later, remove any outstanding weekly stop orders if they haven't triggered.
   // This ensures no weekly pending orders remain over the weekend. Do not set the trade removal flag
   // here, as this is a scheduled cleanup rather than a breakout. Log the action when debugging.
   // Do not remove weekly orders on Friday cutoff when using market orders
  }
